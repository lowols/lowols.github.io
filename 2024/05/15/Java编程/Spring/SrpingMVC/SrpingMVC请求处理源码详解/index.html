<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SrpingMVC请求处理源码详解 | Walon的技术博客</title><meta name="author" content="Leon Walon"><meta name="copyright" content="Leon Walon"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、SpringMVC概述 随着互联网的发展，上面的模式因为是同步调用，性能慢慢的跟不是需求，所以异步调用慢慢的走到了前台，是现在比较流行的一种处理方式。因为是异步调用，所以后端不需要返回view视图，将其去除。前端如果通过异步调用的方式进行交互，后台就需要将返回的数据转换成json格式进行返回  1 开发流程主要组件的关系，前端控制器像之前的servlet类一样放在tomcat这样的Web容器里">
<meta property="og:type" content="article">
<meta property="og:title" content="SrpingMVC请求处理源码详解">
<meta property="og:url" content="https://lowols.github.io/2024/05/15/Java%E7%BC%96%E7%A8%8B/Spring/SrpingMVC/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Walon的技术博客">
<meta property="og:description" content="一、SpringMVC概述 随着互联网的发展，上面的模式因为是同步调用，性能慢慢的跟不是需求，所以异步调用慢慢的走到了前台，是现在比较流行的一种处理方式。因为是异步调用，所以后端不需要返回view视图，将其去除。前端如果通过异步调用的方式进行交互，后台就需要将返回的数据转换成json格式进行返回  1 开发流程主要组件的关系，前端控制器像之前的servlet类一样放在tomcat这样的Web容器里">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-05-15T03:22:47.000Z">
<meta property="article:modified_time" content="2024-10-28T00:22:14.197Z">
<meta property="article:author" content="Leon Walon">
<meta property="article:tag" content="SpringMVC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lowols.github.io/2024/05/15/Java%E7%BC%96%E7%A8%8B/Spring/SrpingMVC/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"LT5E5X8OYT","apiKey":"fb3624e785e54a179df31308a732967b","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SrpingMVC请求处理源码详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-28 08:22:14'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/top.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Walon的技术博客"><span class="site-name">Walon的技术博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SrpingMVC请求处理源码详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-15T03:22:47.000Z" title="发表于 2024-05-15 11:22:47">2024-05-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-28T00:22:14.197Z" title="更新于 2024-10-28 08:22:14">2024-10-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SrpingMVC请求处理源码详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、SpringMVC概述"><a href="#一、SpringMVC概述" class="headerlink" title="一、SpringMVC概述"></a>一、SpringMVC概述</h1><blockquote>
<p>随着互联网的发展，上面的模式因为是同步调用，性能慢慢的跟不是需求，所以异步调用慢慢的走到了前台，是现在比较流行的一种处理方式。因为是异步调用，所以后端不需要返回view视图，将其去除。前端如果通过异步调用的方式进行交互，后台就需要将返回的数据转换成json格式进行返回</p>
</blockquote>
<h3 id="1-开发流程"><a href="#1-开发流程" class="headerlink" title="1 开发流程"></a>1 开发流程</h3><p>主要组件的关系，前端控制器像之前的servlet类一样放在tomcat这样的Web容器里，但是DispatchServlet引入了Spring的IOC容器。</p>
<p>也就是为其定制的WebApplicationContext。这个容器是作为DispatchServlet的一个成员存在的，帮助DispatchServlet管理一些功能组件【映射器，处理器等】。</p>
<h1 id="二、Spring-MVC主流程源码分析"><a href="#二、Spring-MVC主流程源码分析" class="headerlink" title="二、Spring-MVC主流程源码分析"></a>二、Spring-MVC主流程源码分析</h1><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p>Spring MVC相对于前面的章节是比较简单的，我们首先引用《Spring in Action》上的一张图来了解Spring MVC的核心组件和大致处理流程：</p>
<p><img src="http://fastly.jsdelivr.net/gh/lowols/Pictures@main/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_Img/page18image39566784-1723013900694-6.jpg" alt="page18image39566784.jpg"></p>
<h1 id="二、运行调用阶段源码详细分析"><a href="#二、运行调用阶段源码详细分析" class="headerlink" title="二、运行调用阶段源码详细分析"></a>二、运行调用阶段源码详细分析</h1><h1 id="SpringMVC处理请求源码分析——part1-整体流程"><a href="#SpringMVC处理请求源码分析——part1-整体流程" class="headerlink" title="SpringMVC处理请求源码分析——part1 整体流程"></a>SpringMVC处理请求源码分析——part1 整体流程</h1><blockquote>
<p>本文主要讲SpringMVC处理HTTP请求的流程，本篇笔记的部分内容源自尚硅谷的雷丰阳老师。但笔者在学习过程中发现雷丰阳老师源码虽然讲的非常棒，但缺少对整体架构或者概览的把握，这点导致很多同学在学习时过于深入细节，最后一头雾水。因此笔者写下本篇笔记，想从简到繁，比较清晰的捋一下SpringMVC处理请求的大体源码过程。</p>
<p>本文力求深入浅出，尽量少的大幅贴源码，先从大概流程再到具体细节这样的过程来讲解。</p>
<p>笔<strong>记将会分为三部分：整体流程源码分析、具体场景源码分析和额外补充功能分析。</strong></p>
<p><strong>本篇笔记是第一部分，整体流程的源码分析，想先让大家对SpringMVC执行的整体流程有个概念。</strong></p>
<p>本篇笔记适合有一定SpringMVC基础的同学，至少知道常用注解如<code>@ResponseBody</code>，<code>@RequestBody</code>的功能，以及<code>ModelAndView</code>，<code>Model</code>，<code>Map</code>等类的作用。</p>
<p>本篇笔记的SpringBoot版本是2.7.2。</p>
</blockquote>
<h2 id="1-先从DispatcherServlet说起"><a href="#1-先从DispatcherServlet说起" class="headerlink" title="1. 先从DispatcherServlet说起"></a>1. 先从DispatcherServlet说起</h2><p>有Servlet基础的同学应该都知道，前端的每一个请求都会由一个Servlet来处理。在最原始的Java Web开发中，我们需要写自己的Servlet，然后再标注上这个Servlet是处理什么URL路径的，这样当一个HTTP请求到来时，就可以根据请求的路径找到我们的Servlet，再调用这个Servlet来处理请求。</p>
<p>在SpringMVC的开发中，我们需要配一个特殊的Servlet叫<code>DispatcherServlet</code>（这个东西是Spring帮我们写好的），然后我们再为<code>DispatcherServlet</code>配置映射的URL路径为<code>/</code>。其中<code>/</code>是个通配符，代表它能处理所有URL的请求。这代表所有的HTTP请求都会打到了<code>DispatcherServlet</code>上，那么此时我们的开发就由：</p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208072140762.png"><img src="http://fastly.jsdelivr.net/gh/lowols/Pictures@main/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_Img/1722865555-350faf9f4eda90a688365621a753f721.png" alt="image-20220807214026624" title="image-20220807214026624"></a></p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208072140762.png">image-20220807214026624</a></p>
<p>转为了：</p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208072142142.png"><img src="http://fastly.jsdelivr.net/gh/lowols/Pictures@main/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_Img/1722865555-038f04a3cc671e0bd1c151a5e765adea.png" alt="image-20220807214258080" title="image-20220807214258080"></a></p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208072142142.png">image-20220807214258080</a></p>
<p>其中上图的<strong>后端处理</strong>就是我们自己写的Controller里的每个方法。</p>
<p>这样就有了一个问题，<strong>为什么要那么做？为什么要将所有的请求都打到一个Servlet上再由这个Servlet分发？</strong></p>
<p>原因很简单，<strong>就是Spring想掌控一切</strong>。Spring想拦截所有的HTTP请求并对每个请求做一定的处理，<strong>让我们能够尽量少的关心HTTP请求和响应，尽可能多的关心业务</strong>。</p>
<p>比如，我们往往会写这样一个创建用户的请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上述Controller中，我们的参数User对象是如何从HTTP请求中解析到的，又是如何将返回给前端的数据写进HTTP响应的，这些我们都不需要关心，这些其实都是<code>DispatcherServlet</code>这个类帮我们做了。</p>
<p>有了上面这些思想后，我们来看下<code>DispatcherServlet</code>类的继承结构：</p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208072159757.png"><img src="http://fastly.jsdelivr.net/gh/lowols/Pictures@main/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_Img/1722865555-e1e83e075de38ebbd0e7b651168bf9fe.png" alt="image-20220807215941684" title="image-20220807215941684"></a></p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208072159757.png">image-20220807215941684</a></p>
<p>可以看到<code>DispatcherServlet</code>是一个Servlet实现类。而我们又知道处理Http请求的Servlet必须是<code>HttpServlet</code>，<code>HttpServlet</code>内规定了<code>doGet()、doPost()、doPut()</code>等方法，其中<code>FrameworkServlet</code>类(上图的倒数第二个类)重写了这些方法，它对这些方法的重写都一模一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FrameworkServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServletBean</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doPut</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>都是调用<code>processRequest()</code>方法，而<code>processRequest()</code>方法又会调用<code>doService()</code>方法。<code>doService()</code>是<code>FrameworkServlet</code>的抽象方法，这个方法由<code>DispatcherServlet</code>实现，<code>DispatcherServlet#doService()</code>又调用了<code>DispatcherServlet#doDispatch()</code>方法。其时序图如下：</p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208072236911.png"><img src="http://fastly.jsdelivr.net/gh/lowols/Pictures@main/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_Img/1722865555-f25a6c7f1f999a31c8a14d64cfa51434.png" alt="image-20220807223638836" title="image-20220807223638836"></a></p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208072236911.png">image-20220807223638836</a></p>
<p>其中，**<code>DispatcherServlet#doDispatch()</code><strong>是最核心的方法，</strong>对于SpringMVC处理请求的源码分析往往也是对<code>DispatcherServlet#doDispatch()</code>的分析**。</p>
<h2 id="2-doDispatch做了什么"><a href="#2-doDispatch做了什么" class="headerlink" title="2. doDispatch做了什么"></a>2. doDispatch做了什么</h2><p>简单来讲，<code>doDispatch()</code>做了四件事：</p>
<ol>
<li>根据HTTP请求的信息找到我们的处理方法(包括方法的适配器，我们一会说)</li>
<li>使用适配器，根据HTTP请求信息和我们的处理方法，解析出请求参数，并执行我们的处理方法。</li>
<li>将处理方法的返回结果进行处理</li>
<li>视图解析</li>
</ol>
<p>其中我们的处理方法就是Controller层里面每一个标了<code>@RequestMapping</code>(<code>@GettingMapping</code>、<code>@PostMapping</code>等也属于<code>@RequestMapping</code>)注解的方法。</p>
<p><code>doDispatch()</code>源码中这四步流程的具体执行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//对应步骤1，找到处理方法</span></span><br><span class="line">    mappedHandler = getHandler(processedRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应步骤1，找到处理方法的适配器(适配器我们下面会说，别着急)</span></span><br><span class="line">    <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应步骤2和步骤3，解析参数，执行方法，并处理方法的返回</span></span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应步骤4 视图解析</span></span><br><span class="line">    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将<code>doDispatch()</code>中比较重要的源码拿了出来，这样看起来更加清晰明了，这些重要的源码就分别对应我们上面说的4个步骤。下面我们会一一说一下每个步骤SpringMVC都做了什么。</p>
<h2 id="3-第一步-找到处理方法"><a href="#3-第一步-找到处理方法" class="headerlink" title="3. 第一步 找到处理方法"></a>3. 第一步 找到处理方法</h2><p>要想处理请求，必然要先找到能处理这个请求的方法。SpringMVC分为两步来寻找，<strong>第一步是找到我们的Controller里自己写的那个方法，称作handler（处理器）。第二步是通过这个handler找到对应的适配器，称作handlerAdapter。</strong></p>
<h3 id="3-1-找到handler"><a href="#3-1-找到handler" class="headerlink" title="3.1 找到handler"></a>3.1 找到handler</h3><h4 id="3-1-1-HandlerMapping"><a href="#3-1-1-HandlerMapping" class="headerlink" title="3.1.1 HandlerMapping"></a>3.1.1 HandlerMapping</h4><p>先介绍一个接口<code>HandlerMapping</code>，它翻译过来是请求映射处理器。我们可以这样理解：</p>
<p>对于后端来讲，我们把HTTP请求分为几种：比如请求静态资源的，请求动态处理的，请求欢迎页的等。每一种类型的HTTP请求都需要一个专门的处理器来处理，这些处理器就是<code>HandlerMapping</code>。换句话说一个<code>HandlerMapping</code>实现类就是一个场景下的HTTP请求处理器。</p>
<p><code>DispatcherServlet</code>类内部有一个属性<code>handlerMappings</code>，这个属性里面装了一些<code>HandlerMapping</code>的实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">FrameworkServlet</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>默认情况下<code>handlerMappings</code>里有5个实现类，分别是<code>RequestMappingHandlerMapping</code>、<code>BeanNameUrlHandlerMapping</code>、<code>RouterFunctionMapping</code>、<code>SimpleUrlHandlerMapping</code>和<code>WelcomePageHandlerMapping</code>。</p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208080003607.png"><img src="http://fastly.jsdelivr.net/gh/lowols/Pictures@main/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_Img/1722865555-dd6f7ddccfbbd25ecc46c6ac9758bab3.png" alt="image-20220808000313545" title="image-20220808000313545"></a></p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208080003607.png">image-20220808000313545</a></p>
<p>看名字大概也可以猜到这些<code>HandlerMapping</code>的应用场景，比如<code>SimpleUrlHandlerMapping</code>是用来处理静态页面请求的，<code>WelcomePageHandlerMapping</code>是用来处理欢迎页请求的。而<strong>对于动态请求的处理，也即执行我们Controller里的方法(handler)的请求，是由<code>RequestMappingHandlerMapping</code>实现的</strong>。</p>
<h4 id="3-1-2-DispatcherServlet-getHandler"><a href="#3-1-2-DispatcherServlet-getHandler" class="headerlink" title="3.1.2 DispatcherServlet#getHandler()"></a>3.1.2 DispatcherServlet#getHandler()</h4><p>了解了这些后，我们再来看SpringMVC是如何找到我们的hander的，根据上面的源码我们知道首先会执行<code>getHandler()</code>方法，<code>getHandler()</code>就是遍历<code>DispatcherServlet</code>类内<code>handlerMappings</code>的所有<code>HandlerMapping</code>，挨个调用它们的<code>getHandler()</code>方法，谁先有返回就代表找到了（这里返回的是<code>HandlerExecutionChain</code>，而非<code>HandlerMapping</code>，主要原因是<code>HandlerExecutionChain</code>封装了一些拦截器，我们讲到拦截器时再说，大家可以简单认为<code>HandlerExecutionChain</code>和<code>HandlerMapping</code>是一样的）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历handlerMappings里的每个HandlerMapping实现类，判断哪个HandlerMapping能处理这个HTTP请求</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerMapping mapping : <span class="built_in">this</span>.handlerMappings) &#123;</span><br><span class="line">            <span class="comment">//一旦HandlerMapping的getHandler()有返回，就代表这个找到了能处理的handler</span></span><br><span class="line">            <span class="type">HandlerExecutionChain</span> <span class="variable">handler</span> <span class="operator">=</span> mapping.getHandler(request);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>我们之前说了对于HTTP的动态请求的是由<code>RequestMappingHandlerMapping</code>来处理的，那也就是<code>RequestMappingHandlerMapping#getHandler()</code>有返回，那么我们看下它是怎么处理的。</p>
<h4 id="3-1-3-RequestMappingHandlerMapping-getHandler"><a href="#3-1-3-RequestMappingHandlerMapping-getHandler" class="headerlink" title="3.1.3 RequestMappingHandlerMapping#getHandler()"></a>3.1.3 RequestMappingHandlerMapping#getHandler()</h4><ol>
<li><p>MappingRegistry与HandlerMethod</p>
<p>这里又需要插入一个知识，我们要先讲一个叫做<code>MappingRegistry</code>的东西。<code>MappingRegistry</code>翻译过来叫做映射器注册中心。也即所有的映射器都需要注册到这里，它就像是一个大集合，装了所有的映射器。那什么是映射器呢？就是我们的handler，也即我们自己写的Controller里的方法。也就是说在项目启动的时候，Spring会扫描我们这个项目下所有标注了<code>@Controller</code>注解的类，然后再扫描这些类里面标了<code>@RequestMapping</code>(<code>@GettingMapping</code>、<code>@PostMapping</code>等也属于<code>@RequestMapping</code>)注解的方法，并将这些方法封装注册到<code>MappingRegistry</code>中。<strong>Spring将我们这些方法统一封装成<code>HandlerMethod</code>对象。</strong><code>HandlerMethod</code>内的属性挺丰富的，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerMethod</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法所在的对象，比如getUsr()方法在UserController对象里</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object bean;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法本身</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法的参数信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodParameter[] parameters;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>我们之前说了<code>MappingRegistry</code>是一个大的集合，这个集合装了所有Controller类内标了<code>@RequestMapping</code>的方法。因此我们必然能根据HTTP请求从<code>MappingRegistry</code>中找到我们的处理方法。<code>MappingRegistry</code>内部有两个非常重要的Map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MappingRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MultiValueMap&lt;String, T&gt; pathLookup = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>首先<code>MappingRegistration</code>是一个包装类，它包装了我们上面说的<code>HandlerMethod</code>，部分信息如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MappingRegistration</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T mapping;</span><br><span class="line">    <span class="comment">//可以看到包装了我们的HandlerMethod</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HandlerMethod handlerMethod;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p><code>pathLookup</code>这个Map，key是URL路径，而value是能处理这个URL路径的方法描述信息（注意是方法描述信息，不是方法本身）。这个Map比较特殊的是一个<code>MultiValueMap</code>，也即<strong>可以根据一个key得到多个value</strong>。这个很正常，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">postUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>我们一个URL路径<code>/user</code>可以对应上述Controller里的三个方法。</p>
<p>而<code>registry</code>这个Map的key是方法描述信息 (就是pathLookup的value)，<code>registry</code>的value是<code>MappingRegistration</code>，也即封装了具体的执行方法。</p>
</li>
<li><p>AbstractHandlerMethodMapping#getHandlerInternal()</p>
<p>了解了<code>MappingRegistry</code>后，我们再回来看<code>RequestMappingHandlerMapping</code>，<code>RequestMappingHandlerMapping</code>类的父类是<code>AbstractHandlerMethodMapping</code>，这个类内持有<code>MappingRegistry</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractHandlerMethodMapping</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AbstractHandlerMapping</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">MappingRegistry</span> <span class="variable">mappingRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingRegistry</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>也即我们刚才分析的<code>MappingRegistry</code>会被<code>AbstractHandlerMethodMapping</code>持有，那也就代表**我们的<code>RequestMappingHandlerMapping</code>这个类拥有项目所有的<code>HandlerMethod</code>**。</p>
<p>对于<code>RequestMappingHandlerMapping#getHandler()</code>的调用最终会调用到<code>AbstractHandlerMethodMapping#getHandlerInternal()</code>上，其关键源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//先根据HTTP请求得到请求URL路径，比如/user</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> initLookupPath(request);</span><br><span class="line">    <span class="comment">//读写锁，获得读锁，暂时可以不必关心</span></span><br><span class="line">    <span class="built_in">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//根据URL路径和HTTP请求信息从自己的属性MappingRegistry中拿到匹配的HandlerMethod</span></span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> lookupHandlerMethod(lookupPath, request);</span><br><span class="line">        <span class="comment">//找到后将匹配的HandlerMethod返回</span></span><br><span class="line">        <span class="keyword">return</span> (handlerMethod != <span class="literal">null</span> ? handlerMethod.createWithResolvedBean() : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放读锁</span></span><br><span class="line">        <span class="built_in">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>可以看到上述信息核心的地方在<code>lookupHandlerMethod()</code>，其部分关键源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//match是符合的，匹配到的HandlerMethod，一会我们找到的HandlerMethod会放到这个里面</span></span><br><span class="line">    List&lt;Match&gt; matches = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//根据URL路径先找匹配的方法信息（注意是方法信息，不是方法本身）</span></span><br><span class="line">    <span class="comment">//我们上面说过，根据URL路径寻找可能会找到多个符合的方法，比如GET/user POST/user DELETE/user </span></span><br><span class="line">    List&lt;T&gt; directPathMatches = <span class="built_in">this</span>.mappingRegistry.getMappingsByDirectPath(lookupPath);</span><br><span class="line">    <span class="keyword">if</span> (directPathMatches != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//再根据HTTP请求的其他信息(比如请求类型(GET,POST等)），进一步寻找符合的处理方法</span></span><br><span class="line">        <span class="comment">//并将找到的方法放入matches里面</span></span><br><span class="line">        addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面就是一些异常判断了</span></span><br><span class="line">    <span class="comment">//比如如果matchers是空的话，也即没找到能处理的方法要怎么办啦</span></span><br><span class="line">    <span class="comment">//如果找到不只一个能处理的方法就抛出异常啦之类的</span></span><br><span class="line">    <span class="comment">//正常情况下我们只会找到一个能处理的方法，将这个方法返回即可</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>这里很容易想到<code>this.mappingRegistry.getMappingsByDirectPath(lookupPath)</code>其实就是从<code>MappingRegistry</code>中的<code>pathLookup</code>这个Map里面去取信息（还记得吗，我们刚说过<code>MappingRegistry</code>内部的两个重要map）。</p>
<p>根据URL路径匹配完以后，肯定还得结合HTTP请求，再详细的判断这个方法是否满足需求（比如我要的是GET，你的方法是POST，那肯定就不行）做一层筛选，这样筛选下来得到的方法描述信息，再作为key值，从<code>MappingRegistry</code>中的<code>registry</code>这个Map里面去取具体的方法。而这个就是<code>addMatchingMappings()</code>方法的实现细节。感兴趣的可以自己点进去这两个方法细节，实际很简单，就几行代码，这里不再贴出。</p>
</li>
</ol>
<h4 id="3-1-4-总结"><a href="#3-1-4-总结" class="headerlink" title="3.1.4 总结"></a>3.1.4 总结</h4><p>走完上面的流程，我们已经拿到了能处理请求的<code>HandlerMethod</code>，我们可以总结：</p>
<p>首先<code>DispatcherServlet</code>内部有5个<code>HandlerMapping</code>，它会挨个询问哪个<code>HandlerMapping</code>能处理这个请求，结果是我们的<code>RequestMappingHandlerMapping</code>能处理。<code>RequestMappingHandlerMapping</code>这个对象的内部有一个叫<code>MappingRegistry</code>的大集合，这个集合里面装了我们项目所有的自己编写的Controller里处理请求的方法，它将我们的方法封装为<code>HandlerMethod</code>，当<code>RequestMappingHandlerMapping</code>去处理的时候实际上就是根据HTTP 信息（比如请求类型和URL路径）去<code>MappingRegistry</code>里面找符合的<code>HandlerMethod</code>，将找到的<code>HandlerMethod</code>返回。</p>
<p>流程大致如下图：</p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208081717090.png"><img src="http://fastly.jsdelivr.net/gh/lowols/Pictures@main/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_Img/1722865555-8feb2b909e2ee07304d72070c9317dbf.png" alt="image-20220808171735041" title="image-20220808171735041"></a></p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208081717090.png">image-20220808171735041</a></p>
<h4 id="3-1-5-一些补充"><a href="#3-1-5-一些补充" class="headerlink" title="3.1.5 一些补充"></a>3.1.5 一些补充</h4><ol>
<li><p>handlerMappings内的元素是有顺序的</p>
<p>我们上面看到<code>DispatcherServlet</code>里的<code>handlerMappings</code>有5个实现类，都放在一个List里面，它们其实是有顺序的（父类<code>AbstractHandlerMapping</code>继承接口<code>Ordered</code>），<code>RequestMappingHandlerMapping</code>在最前面，这有什么影响呢？举个例子：</p>
<p>假设我的SpringBoot项目现在有一个静态文件叫hello.html</p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208081630132.png"><img src="http://fastly.jsdelivr.net/gh/lowols/Pictures@main/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_Img/1722865555-388467f1a3ba0abac55dc5f344d6bdb8.png" alt="image-20220808163009080" title="image-20220808163009080"></a></p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208081630132.png">image-20220808163009080</a></p>
<p>默认情况下，我通过访问<code>localhost:8080/hello.html</code>，SpringBoot就会将这个静态文件返回给浏览器。但如果这个时候我有个Controller，它是这样写的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello.html&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>那么请问此时再访问<code>localhost:8080/hello.html</code>还会返回静态文件吗，还是会走到我们的Controller返回<code>&quot;hello world&quot;</code>字符串呢？</p>
<p>答案是会走进Controller返回<code>&quot;hello world&quot;</code>字符串。原因也很简单，因为<code>RequestMappingHandlerMapping</code>在<code>SimpleUrlHandlerMapping</code>前面，<code>DispatcherServlet</code>会先问<code>RequestMappingHandlerMapping</code>能不能处理。在我们没写这个Controller时，<code>RequestMappingHandlerMapping</code>肯定是没法从<code>MappingRegistry</code>找到匹配的处理方法的，所以就处理不了，这时才会轮到后面的<code>SimpleUrlHandlerMapping</code>来处理，然后返回静态页面。但当我们写了这个Controller，自然<code>RequestMappingHandlerMapping</code>能找到处理方法，也就没后面<code>SimpleUrlHandlerMapping</code>什么事了。</p>
</li>
<li><p>MappingRegistry里的读写锁</p>
<p>刚才我们在源码里看到了<code>MappingRegistry</code>的读写锁，这个原因也挺简单的，首先<code>MappingRegistry</code>是一个注册中心，自然就允许有人往里注册或注销东西，比如MappingRegistry的部分功能如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MappingRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(T mapping, Object handler, Method method)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">(T mapping)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>所谓注册和注销，本质上就是在操作<code>MappingRegistry</code>里面的那些装了我们方法的集合。同时<code>MappingRegistry</code>又会被大量的查询（每次HTTP请求来了以后都会向它查询能处理的方法），因此这是一个典型的<strong>读多写少</strong>的场景，为保证并发安全且尽可能的提高性能，读写锁就是很好的选择。读锁之间共享，写锁独占，同时写的时候不能读。</p>
<p>从<code>MappingRegistry</code>的API，我们也可以大胆猜测，在项目运行期间，我们也可以向其注册和删除<code>HandlerMethod</code>。</p>
</li>
</ol>
<h3 id="3-2-找到handlerAdapter"><a href="#3-2-找到handlerAdapter" class="headerlink" title="3.2 找到handlerAdapter"></a>3.2 找到handlerAdapter</h3><h4 id="3-2-1-HandlerAdapter"><a href="#3-2-1-HandlerAdapter" class="headerlink" title="3.2.1 HandlerAdapter"></a>3.2.1 HandlerAdapter</h4><p>在说寻找handlerAdapter之前，我们先来说下为什么需要handlerAdapter。</p>
<p>走到这一步的时候，想想我们拿到了什么？拿到了能处理请求的<code>HandlerMethod</code>，以及拥有HTTP请求的所有信息和HTTP响应。那正常来说就是根据HTTP请求的信息，调用我们的<code>HandlerMethod</code>来处理请求，处理完后将处理结果写进HTTP响应。但是我们知道HTTP请求是五花八门的，比如参数放在请求头或请求体，以form形式提交，以JSON格式提交等等。同时我们自己的Controller层函数写法也是各种各样，加<code>@RequestParam</code>注解的，加Cookie、Session信息的，想返回页面的，想返回数据的等等。</p>
<p>我们将HTTP请求类比为插头，<code>HandlerMethod</code>类比为插座，为了让这些插头和插座能够结合，就需要一个适配器，插头插在适配器上，适配器插在插座上，这样任何类型的请求，任何不同的处理方法，都会有一个适配器来处理。</p>
<p><strong>Spring将这种适配器称作<code>HandlerAdapter</code>。</strong></p>
<p>与<code>handlerMappings</code>相同，<code>DispatcherServlet</code>内部也有一个属性叫<code>handlerAdapters</code>，这个属性里面也装了一些<code>HandlerAdapter</code>的实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">FrameworkServlet</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>默认情况下，这个List集合里有4个实现类，分别是<code>RequestMappingHandlerAdapter</code>、<code>HandlerFunctionAdapter</code>、<code>HttpRequestHandlerAdapter</code>和<code>SimpleControllerHandlerAdapter</code>。</p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208041851651.png"><img src="http://fastly.jsdelivr.net/gh/lowols/Pictures@main/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_Img/1722865555-436aebd5e4f85f83d97d7ba3ec305e2f.png" alt="image-20220804185151491" title="image-20220804185151491"></a></p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208041851651.png">image-20220804185151491</a></p>
<p>根据名字可以看出，这些适配器与<code>HandlerMapping</code>是有对应关系的。比如<code>RequestMappingHandlerMapping</code>与<code>RequestMappingHandlerAdapter</code>是对应的，说明<code>RequestMappingHandlerAdapter</code>是用于适配<code>RequestMappingHandlerMapping</code>映射器的。</p>
<h4 id="3-2-2-DispatcherServlet-getHandlerAdapter"><a href="#3-2-2-DispatcherServlet-getHandlerAdapter" class="headerlink" title="3.2.2 DispatcherServlet#getHandlerAdapter()"></a>3.2.2 DispatcherServlet#getHandlerAdapter()</h4><p>根据之前的源码，我们知道<code>getHandlerAdapter()</code>函数就是用来获得适配器的，它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerAdapter <span class="title function_">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HandlerAdapter adapter : <span class="built_in">this</span>.handlerAdapters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">                <span class="keyword">return</span> adapter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;No adapter for handler [&quot;</span> + handler +</span><br><span class="line">                               <span class="string">&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>可以看到，十分简单，就是挨个问<code>handlerAdapters</code>里的每一个<code>HandlerAdapter</code>，谁支持适配这个请求处理，谁支持就返回谁。</p>
<p>我们刚才知道<code>RequestMappingHandlerMapping</code>的适配器是<code>RequestMappingHandlerAdapter</code>，那也就代表，这里正常会返回<code>RequestMappingHandlerAdapter</code>，我们不妨走进<code>RequestMappingHandlerAdapter#support()</code>，看看它是如何判断的。</p>
<h4 id="3-2-3-RequestMappingHandlerAdapter-support"><a href="#3-2-3-RequestMappingHandlerAdapter-support" class="headerlink" title="3.2.3 RequestMappingHandlerAdapter#support()"></a>3.2.3 RequestMappingHandlerAdapter#support()</h4><p><code>RequestMappingHandlerAdapter#support()</code>会进入<code>AbstractHandlerMethodAdapter#supports()</code>，其中<code>AbstractHandlerMethodAdapter</code>是<code>RequestMappingHandlerAdapter</code>的父类，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractHandlerMethodAdapter</span> <span class="keyword">extends</span> <span class="title class_">WebContentGenerator</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span>, Ordered &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p><code>supportsInternal()</code>由子类<code>RequestMappingHandlerAdapter</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandlerMethodAdapter</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, InitializingBean &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">supportsInternal</span><span class="params">(HandlerMethod handlerMethod)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>可以看到，<code>RequestMappingHandlerAdapter</code>的判断逻辑很简单，就是问找到的handler是不是<code>HandlerMethod</code>类型，通过前面的源码分析，我们很清楚handler就是<code>HandlerMethod</code>。</p>
<p>至此我们就找到了我们的<code>HandlerMethod</code>和<code>HandlerAdapter</code>，完成了<code>DispatcherServlet#doDispatch()</code>的第一步：根据HTTP请求的信息找到我们的处理方法(包括方法的适配器)。</p>
<h4 id="3-2-4-总结"><a href="#3-2-4-总结" class="headerlink" title="3.2.4 总结"></a>3.2.4 总结</h4><p>我们在3.1节中已经找到了<code>HandlerMethod</code>，但考虑到HTTP请求信息比较多，如何将HTTP请求的信息与我们的<code>HandlerMethod</code>参数信息进行匹配，以及又如何将<code>HandlerMethod</code>处理完的结果返回给HTTP响应，这就需要适配器，我们需要找到合适的适配器来进行后续的工作。</p>
<p>与<code>handlerMappings</code>相同，<code>DispatcherServlet</code>内的<code>handlerAdapters</code>装了一些<code>HandlerAdapter</code>的实现类。处理动态请求会由<code>RequestMappingHandlerAdapter</code>适配器来处理，而<code>RequestMappingHandlerAdapter</code>判断能处理的逻辑也很简单，就是看上一步得到的处理器是不是<code>HandlerMethod</code>。拿到适配器后，我们就可以将HTTP请求信息与我们的<code>HandlerMethod</code>进行适配了。</p>
<h2 id="4-第二步-解析参数"><a href="#4-第二步-解析参数" class="headerlink" title="4. 第二步 解析参数"></a>4. 第二步 解析参数</h2><p>在讲参数解析前，我们先回顾下目前已经走了哪些步骤，得到了哪些东西：</p>
<p>首先我们根据HTTP请求，从<code>MappingRegistry</code>中得到了能处理请求的<code>HandlerMethod</code>，其次为将HTTP请求与我们的<code>HandlerMethod</code>适配，又根据<code>HandlerMethod</code>找到了适配器<code>RequestMappingHandlerAdapter</code>，现在我们拥有的就是</p>
<ul>
<li>实际的处理器<code>HandlerMethod</code></li>
<li>适配器<code>RequestMappingHandlerAdapter</code></li>
<li>HTTP请求和HTTP响应</li>
</ul>
<p>我们之前说了由于HTTP请求和<code>HandlerMethod</code>五花八门，因此需要适配器来帮忙执行HTTP请求。那适配器到底帮了哪些忙呢？</p>
<p>实际上就两点：<strong>参数解析和返回结果的处理</strong>。适配器会首先根据HTTP请求信息和我们的<code>HandlerMethod</code>，解析HTTP请求，将它转为我们<code>HandlerMethod</code>上的参数。举个例子，前端通过form表单发送HTTP请求：</p>
<p>form表单内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=tom&amp;age=<span class="number">18</span>&amp;pet.name=myDog&amp;pet.age=<span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>JSON</p>
<p><em>复制</em></p>
<p>后端Controller:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">postUser</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>SpringMVC会自动将表单中的字符串信息转为我们的User参数对象。</p>
<p>得到所有参数后，适配器会直接调用<code>HandlerMethod</code>处理请求。这时我们又得到了处理的返回结果。这个结果的意义也是众多的，它可以是一个对象然后用JSON写出，也可以是一个页面，还可以是一个跳转或重定向，不同的返回情况都需要被特殊适配处理，这些东西也是适配器帮我们做的。</p>
<p>为了让大家回想起<code>DispatcherServlet#doDispatch()</code>的四个步骤，我们再将源码贴过来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//对应步骤1，找到处理方法</span></span><br><span class="line">    mappedHandler = getHandler(processedRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应步骤1，找到处理方法的适配器(适配器我们下面会说，别着急)</span></span><br><span class="line">    <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应步骤2和步骤3，解析参数，执行方法，并处理方法的返回</span></span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应步骤4 视图解析</span></span><br><span class="line">    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>其中<code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code>就是适配器做的工作：<strong>参数解析，执行方法并处理执行返回</strong>。</p>
<p>在本章中我们先学习参数解析，下一章讲返回结果的处理。</p>
<h3 id="4-1-先从一个设计模式说起"><a href="#4-1-先从一个设计模式说起" class="headerlink" title="4.1 先从一个设计模式说起"></a>4.1 先从一个设计模式说起</h3><p>为便于理解参数解析的设计思想，我们先从一个设计模式讲起，理解这个设计模式对于SpringMVC的学习很关键。</p>
<p>我们假设现在你是一个包工头，你的手底下有很多技术工，有能刷墙的，能砌砖的，能设计图纸的还有能开挖掘机的。很多房地产开发商有活的时候会找你。比如今天恒太房地产跟你说他现在手里有一个刷墙的活问你能不能干。你二话不说接了这个活并派出了刷墙技术工来干活。</p>
<p>针对上面这个场景，我们可以抽象为代码，首先我们有个工人接口。刷墙工，砌砖工等都属于这个接口的实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Worker</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>每个工人首先需要明确自己自己能干哪些活，比如刷墙工只能干刷墙的活，他干不了砌砖。怎么明确呢，只能问。比如现在来了一个活，我得问下刷墙工能不能干。因此就需要一个<code>support(Object work)</code>方法，表明当前工人能不能干这个活。同时如果能干，还得有个实际干活的功能，因此我们的<code>Worker</code>接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Worker</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前工人是否能干这个活 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(Object work)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果能干就实际的干</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(Object work)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>由于你是个包工头，因此你手里应该有一批工人，我们可以使用类<code>Boss</code>描述包工头：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Boss</span>&#123;</span><br><span class="line">    List&lt;Worker&gt; workerList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p><code>workerList</code>就表示你手里拥有的众多工人。</p>
<p>现在，某客户有活过来了，你得判断谁能接这个活，然后交给他干。比较简单的办法就是挨个问手底下的工人，谁能干就让谁干。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Boss</span>&#123;</span><br><span class="line">    List&lt;Worker&gt; workerList;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历询问谁能干，谁能干就让谁干</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(Object work)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Worker worker : workerList)&#123;</span><br><span class="line">            <span class="keyword">if</span>(worker.support(work))&#123;</span><br><span class="line">                worker.doWork(work);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//都不能干就抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;抱歉，我们这接不了这种活&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>这样，其实我们就完成了一个设计模式，叫<strong>策略模式</strong>。</p>
<p>什么是策略模式？<strong>我们可以将上面的工人都理解为某种策略，当有任务来的时候，就需要选择一个正确的策略来处理这个任务。我们将策略抽象为接口（或抽象类），然后自己持有这个接口（或抽象类）的集合</strong>。类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A接口是策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="comment">//B对象持有A的实现类集合</span></span><br><span class="line">    List&lt;A&gt; aList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>后面源码的分析中，<strong>策略模式会使用的非常频繁</strong>。其实如果你细心观察会发现之前的<code>DispatcherServlet</code>里的<code>handlerMappings</code>和<code>handlerAdapters</code>也是策略模式，每个<code>HandlerMapping</code>或<code>HandlerAdapter</code>的实现类都是一种策略，然后我们的<code>DispatcherServlet</code>持有这些策略，当有HTTP请求到来时，就遍历这些策略判断哪个能处理，找到那个能处理的策略来处理任务。</p>
<h3 id="4-2-参数解析"><a href="#4-2-参数解析" class="headerlink" title="4.2 参数解析"></a>4.2 参数解析</h3><p>了解了策略模式，我们来看下参数解析的源码。</p>
<p><code>ha.handle()</code>的具体执行会走到<code>RequestMappingHandlerAdapter#handleInternal()</code>，而<code>handleInternal()</code>又会调用<code>RequestMappingHandlerAdapter#invokeHandlerMethod()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandlerMethodAdapter</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, InitializingBean &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ModelAndView <span class="title function_">handleInternal</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                          HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ModelAndView mav;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//一些校验和特殊情况的判断，比如加session锁</span></span><br><span class="line">        <span class="comment">//最终会执行invokeHandlerMethod</span></span><br><span class="line">        mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>因此我们先来分析下<code>RequestMappingHandlerAdapter#invokeHandlerMethod()</code></p>
<h4 id="4-2-1-RequestMappingHandlerAdapter-invokeHandlerMethod"><a href="#4-2-1-RequestMappingHandlerAdapter-invokeHandlerMethod" class="headerlink" title="4.2.1 RequestMappingHandlerAdapter#invokeHandlerMethod()"></a>4.2.1 RequestMappingHandlerAdapter#invokeHandlerMethod()</h4><ol>
<li><p>HandlerMethodArgumentResolver</p>
<p>本着不大篇幅的贴源码，尽量深入浅出的思想，在讲源码前我们先来说点别的。首先从一个接口<code>HandlerMethodArgumentResolver</code>说起。</p>
<p>我们都知道SpringMVC会根据HTTP请求和我们写的<code>HandlerMethod</code>来解析参数。但是之前也说过，解析参数的情况太多了，比如用<code>@RequestParam</code>从请求头中解析，使用<code>@RequestBody</code>从请求体中解析等。面对如此多的情况，我们不妨使用刚刚学习的策略模式，<strong>将每种情况的处理都认为是一个策略，然后使用一个List将这些策略汇总起来。那么当要解析一个参数的时候，就从集合中取出一个合适的策略来解析这个参数</strong>。SpringMVC就是那么做的。其中对于解析参数的这一策略接口叫做**<code>HandlerMethodArgumentResolver</code>**，我们称为参数解析器。接口的源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">         NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>可以看到一个<code>supportsParameter()</code>一个<code>resolveArgument()</code>，和我们之前讲的包工头例子一模一样。那么自然而言我们需要一个集合来保存<code>HandlerMethodArgumentResolver</code>接口的实现类。<code>RequestMappingHandlerAdapter</code>内有一个<code>argumentResolvers</code>属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandlerMethodAdapter</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, InitializingBean &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodArgumentResolverComposite argumentResolvers;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p><strong>其中<code>HandlerMethodArgumentResolverComposite</code>就是<code>HandlerMethodArgumentResolver</code>的集合</strong>，其内部属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>默认情况下<code>argumentResolvers</code>内包含27个实现类，内容如下：</p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208191605089.png"><img src="http://fastly.jsdelivr.net/gh/lowols/Pictures@main/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_Img/1722865555-9e218de3fffa7e0fe78833fac91d6468.png" alt="image-20220819160536958" title="image-20220819160536958"></a></p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208191605089.png">image-20220819160536958</a></p>
</li>
<li><p>ModelAndView</p>
<p>我们再来说第二个重要的类<code>ModelAndViewContainer</code>，这个类的作用类似于上下文，它保存着整个请求处理过程中的<strong>Model</strong>和<strong>View</strong>。</p>
<p>首先根据MVC思想我们知道，对于一个MVC项目，我们可以给请求响应两种东西：数据和页面。除此以外，在转发或重定向时，往往需要将我们的数据也转发或重定向到下一级请求（转发是同一个HTTP请求，这里只是表述方便）。这时就需要一种数据结构，用来装我们返回的结果，这个结果可以是返回给请求的，也可以是转发到下一级请求处理的（转发和重定向），这就是<code>ModelAndView</code>。因此我们可以理解为<code>ModelAndView</code>就是用来装一次HTTP处理结果的容器，这个容器里主要装了Model和View两个信息。</p>
<p>其实我们在之前的源码中已经看到过<code>ModelAndView</code>了，它实际上贯穿于整个<code>doDispatch()</code>方法，我们不妨将之前<code>DispatcherServelt</code>的重要源码再拿过来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//这里就是先声明了一个ModelAndView</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    mappedHandler = getHandler(processedRequest);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以看到适配器的处理结果就是返回一个ModelAndView</span></span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//视图解析，需要从ModelAndView中拿到视图信息</span></span><br><span class="line">    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p><code>ModelAndViewContainer</code>可以理解为<code>ModelAndView</code>的包装类，这个类在<code>RequestMappingHandlerAdapter#invokeHandlerMethod()</code>处理过程中被创建（我们一会儿会看到），主要是装<code>HandlerMethod</code>的处理结果（如果参数有Map或者Model还会装参数里的Map和Model信息）。</p>
<p><strong>也即<code>ModelAndViewContainer</code>就是适配器在处理一次HTTP请求的上下文信息，这个上下文里面装的是处理过程中的Model和View。</strong><br><code>ModelAndViewContainer</code>源码中几个重要的属性信息如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModelAndViewContainer</span> &#123;</span><br><span class="line">    <span class="comment">//视图信息，可以是一个View，也可能只是一个视图名String</span></span><br><span class="line">    <span class="keyword">private</span> Object view;</span><br><span class="line">    <span class="comment">//数据，本质是个Map，我们在Controller内的函数上写的Map或Model其实都是它</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ModelMap</span> <span class="variable">defaultModel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BindingAwareModelMap</span>();</span><br><span class="line">    <span class="comment">//重定向的数据，也是个Map</span></span><br><span class="line">    <span class="keyword">private</span> ModelMap redirectModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>可以看到<code>ModelAndViewContainer</code>内部维护了一个View和两个Model，分别是默认的Model和重定向的Model。</p>
</li>
<li><p>WebDataBinderFactory</p>
<p>翻译过来就是数据绑定工厂，我们拿之前表单提交的例子来说：</p>
<p>form表单内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=tom&amp;age=<span class="number">18</span>&amp;pet.name=myDog&amp;pet.age=<span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>JSON</p>
<p><em>复制</em></p>
<p>后端Controller:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">postUser</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>这里很明显的是，SpringMVC将form提交的每一个参数信息<strong>绑定</strong>到了我们的User对象上，而这个绑定操作就是<code>WebDataBinderFactory</code>干的工作。</p>
</li>
<li><p>RequestMappingHandlerAdapter#invokeHandlerMethod()</p>
<p>了解了上面那么多以后，我们就可以看下<code>RequestMappingHandlerAdapter#invokeHandlerMethod()</code>，其部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                           HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//webRequest是HttpServletRequest和HttpServletResponse的包装类</span></span><br><span class="line">    <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//ServletInvocableHandlerMethod是一个大的包装器，下面的一系列set操作都是对ServletInvocableHandlerMethod的丰富</span></span><br><span class="line">    <span class="type">ServletInvocableHandlerMethod</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">        invocableMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.argumentResolvers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>) &#123;</span><br><span class="line">        invocableMethod.setHandlerMethodReturnValueHandlers(<span class="built_in">this</span>.returnValueHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">    invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">    invocableMethod.setParameterNameDiscoverer(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建ModelAndViewContainer</span></span><br><span class="line">    <span class="type">ModelAndViewContainer</span> <span class="variable">mavContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line">    <span class="comment">//做一些ModelAndViewContainer的初始化工作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//包装之后的核心执行，包含参数解析，处理器执行和返回结果的处理</span></span><br><span class="line">    invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理完后返回ModelAndView</span></span><br><span class="line">    <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p><code>ServletInvocableHandlerMethod</code>是<code>HandlerMethod</code>的包装类（实际上它继承自<code>HandlerMethod</code>类），它里面装了很多信息，比如装了我们之前说的参数解析器，装了我们的<code>handlerMethod</code>，还装了<code>WebDataBinderFactory</code>等。另外还有一个<code>returnValueHandlers</code>，它是我们的返回结果处理器，还记得我们之前说的，handlerAdpter实际上帮我们做的事是<strong>参数解析和返回结果的处理</strong>。这里的<code>returnValueHandlers</code>就是用于返回结果处理的，我们会在<a href="#5." title="第三步 执行方法并处理返回">第五章执行方法并处理返回</a>时再单独讲。</p>
<p><code>ServletWebRequest</code>也是个包装类，就是将<code>HttpServletRequest</code>和<code>HttpServletResponse</code>合并到了一个类里。<code>ModelAndViewContainer</code>我们在之前已经介绍过了，当都准备好这些信息后，就要开始执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>因此下一步我们就需要追溯：<code>ServletInvocableHandlerMethod#invokeAndHandle()</code>的源码</p>
</li>
</ol>
<h4 id="4-2-2-ServletInvocableHandlerMethod-invokeAndHandle"><a href="#4-2-2-ServletInvocableHandlerMethod-invokeAndHandle" class="headerlink" title="4.2.2 ServletInvocableHandlerMethod#invokeAndHandle()"></a>4.2.2 ServletInvocableHandlerMethod#invokeAndHandle()</h4><p>其部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">      Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...后面是返回结果的处理，我们在第五章讲</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>其中<code>invokeForRequest()</code>是参数解析以及执行<code>HandlerMethod</code>然后得到返回结果。</p>
<p><code>invokeForRequest()</code>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">      Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据HTTP请求解析参数</span></span><br><span class="line">   Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//...一些日志打印</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//得到参数后，反射执行HandlerMethod</span></span><br><span class="line">   <span class="keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>因此参数解析的核心代码就是<code>getMethodArgumentValues()</code>函数</p>
<h4 id="4-2-3-getMethodArgumentValues"><a href="#4-2-3-getMethodArgumentValues" class="headerlink" title="4.2.3 getMethodArgumentValues()"></a>4.2.3 getMethodArgumentValues()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span><br><span class="line">                                           Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到所有的参数信息</span></span><br><span class="line">    MethodParameter[] parameters = getMethodParameters();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//args就是装我们所有的参数，这里先声明出来</span></span><br><span class="line">    Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">    <span class="comment">//遍历所有的参数信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">        <span class="type">MethodParameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...一些参数处理</span></span><br><span class="line">        <span class="comment">//使用参数解析器来解析参数</span></span><br><span class="line">        args[i] = <span class="built_in">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="built_in">this</span>.dataBinderFactory);</span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">        <span class="comment">//一些异常处理</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>可以看到参数解析就是<strong>以我们的<code>HandlerMethod</code>的参数信息为模板，使用解析器，从HTTP请求中拿到信息赋值到我们的参数上</strong>，这样循环遍历<code>HandlerMethod</code>中的每个参数，就可以解析得到所有的参数对象。</p>
<p>那么我们就要看下参数解析器到底是如何解析参数的。</p>
<h4 id="4-2-4-HandlerMethodArgumentResolverComposite-resolveArgument"><a href="#4-2-4-HandlerMethodArgumentResolverComposite-resolveArgument" class="headerlink" title="4.2.4 HandlerMethodArgumentResolverComposite#resolveArgument()"></a>4.2.4 HandlerMethodArgumentResolverComposite#resolveArgument()</h4><p><code>HandlerMethodArgumentResolverComposite#resolveArgument()</code>源码很好理解，就是找到能解析这个参数的参数解析器，然后调用这个找到的解析器解析它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                              NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//得到参数解析器</span></span><br><span class="line">    <span class="type">HandlerMethodArgumentResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> getArgumentResolver(parameter);</span><br><span class="line">    <span class="keyword">if</span> (resolver == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unsupported parameter type [&quot;</span> +</span><br><span class="line">                                           parameter.getParameterType().getName() + <span class="string">&quot;]. supportsParameter should be called first.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析参数</span></span><br><span class="line">    <span class="keyword">return</span> resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>其中获得参数解析器代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HandlerMethodArgumentResolver <span class="title function_">getArgumentResolver</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">    <span class="comment">//先从缓存中寻找，找不到再遍历寻找</span></span><br><span class="line">   <span class="type">HandlerMethodArgumentResolver</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.argumentResolverCache.get(parameter);</span><br><span class="line">   <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="comment">//遍历每一个参数解析器，判断谁能处理这个参数</span></span><br><span class="line">      <span class="keyword">for</span> (HandlerMethodArgumentResolver resolver : <span class="built_in">this</span>.argumentResolvers) &#123;</span><br><span class="line">         <span class="keyword">if</span> (resolver.supportsParameter(parameter)) &#123;</span><br><span class="line">            result = resolver;</span><br><span class="line">             <span class="comment">//找到能处理的参数后就将它放入缓存，保证下次不用再遍历</span></span><br><span class="line">            <span class="built_in">this</span>.argumentResolverCache.put(parameter, result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>这里需要提一嘴的是<code>argumentResolverCache</code>属性，<code>argumentResolverCache</code>作用很简单，就是缓存的功能。一开始项目启动的时候缓存里面没有任何东西，这样解析每个参数就都需要遍历所有的参数解析器，判断谁能支持处理这个参数，一旦找到这个参数解析器就需要将它缓存起来，这样下次再请求的时候就可以直接从缓存拿避免再遍历，节省了下次HTTP请求的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;MethodParameter, HandlerMethodArgumentResolver&gt; argumentResolverCache =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>可以看到<code>argumentResolverCache</code>本质就是一个<code>ConcurrentHashMap</code>，它的key是<code>MethodParameter</code>也即参数信息（可以推测出<code>MethodParameter</code>一定重写了<code>equals()</code>和<code>hashCode()</code>），Value是能处理这个参数的参数解析器。</p>
<p>这里我们又看到了策略模式的使用，使用<code>argumentResolvers</code>将所有参数解析器汇总起来，在真正需要进行参数解析的时候就会挨个问这些参数解析器有没有人能处理这个参数，谁能处理就交由谁处理。</p>
<p>最后的一步就是调用参数解析器解析参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>首先，参数解析器解析参数需要parameter，mavContainer，webRequest，binderFactory四个参数才能解析，每个参数的作用我们一一来说（虽然我们刚才已经讲了一些）：</p>
<ul>
<li><p>parameter 参数模板信息。我现在是参数解析器，我要解析这个参数肯定得有参数信息吧，这个参数是不是标了<code>@RequestBody</code>注解啊，是不是一个复杂类型比如User对象啊等等，如果是的话我得拿到它的Class，反射创建和赋值吧。只有获得这些信息才能从HTTP请求中对应的位置找到参数，按照参数模板信息来生成参数。</p>
</li>
<li><p>mavContainer 我们之前说过，mavContainer 是一次HTTP请求的上下文，用来装返回的Model和View，既然是装返回的信息，那为啥解析参数的时候还需要它呢？在写Controller方法的时候，有一种场景可以如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>我们往参数Model里设置的任何信息，都会被放进返回结果处理，比如可以转发给下一级HTTP请求（或者返给前端）。</p>
<p>那这个参数Model是哪里来的？<strong>就是mavContainer里的defaultModel这个属性</strong>。我们会在具体的例子中再详细的看相关的源码，这里大家只需要大概知道一下就可以。</p>
</li>
<li><p>webRequest 封装了HTTP请求和HTTP响应的类。既然要从HTTP中解析参数，自然就需要HTTP请求和响应的信息，这都是原始数据。</p>
</li>
<li><p>binderFactory 我们之前讲过，数据绑定工厂，将HTTP请求信息与我们的参数的值绑定上的东西，我们会在后面具体使用场景中分析这个东西，大家别急。</p>
</li>
</ul>
<p>可以看到，要解析一个<code>HandlerMethod</code>上的参数，就需要一个特定的参数解析器，而参数解析器在进行解析的时候需要parameter，mavContainer，webRequest，binderFactory的帮助才能解析出来参数。我们上面也看到Spring为我们提供了27种参数解析器（SpringBoot 2.7.2版本下是27个），这27种参数解析器就是为了应付各种场景下的HTTP请求和参数处理：</p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208191605089.png"><img src="http://fastly.jsdelivr.net/gh/lowols/Pictures@main/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_Img/1722865555-9e218de3fffa7e0fe78833fac91d6468.png" alt="image-20220819160536958" title="image-20220819160536958"></a></p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208191605089.png">image-20220819160536958</a></p>
<p>通过上面的名字也很容易看出一些参数解析器的作用，比如<code>@RequestParamMethodArgumentResolver</code>是用来解析标了<code>@RequestParam</code>注解的参数；<code>@PathVariableMethodArgumentRResolver</code>是解析标了<code>@PathVariable</code>注解的参数；<code>@RequestResponseBodyMethodArgumentResolver</code>是用来解析标了<code>@RequestBody</code>注解的参数。</p>
<p><strong>每个参数解析器都会有一定的应用场景，本文目的是帮助大家快速的掌握SpringMvc执行源码的流程，具体的业务场景不在本文展开，后续会专门出文章，从应用角度讲述这些参数解析器的源码。</strong></p>
<h4 id="4-2-5-doInvoke"><a href="#4-2-5-doInvoke" class="headerlink" title="4.2.5 doInvoke()"></a>4.2.5 doInvoke()</h4><p>最后提一嘴<code>HandlerMethod</code>的执行，我们在<a href="#" title="4.2.2    ServletInvocableHandlerMethod#invokeAndHandle(">4.2.2</a>)的源码中已经看到了一段话</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> doInvoke(args);</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>也即解析完所有的参数后就可以执行<code>HandlerMethod</code>了，<code>doInvoke()</code>的源码也很简单，就是单纯的调用<code>method.invoke()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> getBridgedMethod();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...一些异常处理，主要是针对Kotlin</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(getBean(), args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...一些异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>拿到方法，填入bean，填入参数，然后反射执行。</p>
<h4 id="4-2-6-总结"><a href="#4-2-6-总结" class="headerlink" title="4.2.6 总结"></a>4.2.6 总结</h4><p>首先SpringMvc对不同情况下的参数解析定义了一个参数解析器接口，每个参数解析器接口的实现类就是一种情况下的参数解析，借助于策略模式，我们的<code>HandlerAdapter</code>内会有一些参数解析器的实现类。在要执行一个<code>HandlerMethod</code>前肯定要先把这个方法的所有参数解析出来，因此我们就需要遍历这个方法上的每一个参数，为每一个参数寻找一个合适的参数解析器来解析它。寻找合适参数解析器的方法很简单，就是挨个问<code>HandlerAdapter</code>持有的那些参数解析器是否支持解析，一旦有支持的就代表找到了，找到后就调用参数解析器解析参数。参数解析器在解析参数的时候，需要四个帮手才能真正的解析参数，分别是：</p>
<ul>
<li>参数模板，告知这个参数的一些元数据信息</li>
<li>ModelAndView上下文容器，用来处理多参数返回和HTTP请求见传递信息的作用。</li>
<li>原生HTTP请求和HTTP响应</li>
<li>数据绑定工厂，用来将从HTTP请求中解析出的信息绑定到参数对象上</li>
</ul>
<p>目前SpringBoot2.7.2版本有27个参数解析器，他们用于不同的场景。</p>
<h4 id="4-2-7-一些补充"><a href="#4-2-7-一些补充" class="headerlink" title="4.2.7 一些补充"></a>4.2.7 一些补充</h4><p>在获得某个参数的参数解析器后，我们使用<code>argumentResolverCache</code>将这一信息缓存起来，这里就会有个问题：这个缓存的生命周期是怎样的？它会在什么时候销毁？同样两次HTTP请求，后一次会使用前一次保存的缓存解析器信息吗？</p>
<p>要回答这个问题，我们需要追溯源码看下这个缓存的创建时间和执行HTTP请求时的传递过程：</p>
<p>首先<code>argumentResolverCache</code>是<code>HandlerMethodArgumentResolverComposite</code>内的属性，而<code>RequestMappingHandlerAdapter</code>的属性<code>argumentResolvers</code>正是<code>HandlerMethodArgumentResolverComposite</code>：</p>
<p>通过<code>WebMvcAutoConfiguration</code>和<code>RequestMappingHandlerAdapter</code>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@EnableConfigurationProperties(WebProperties.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">DelegatingWebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ResourceLoaderAware</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//@Bean创建RequestMappingHandlerAdapter实例</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> RequestMappingHandlerAdapter <span class="title function_">requestMappingHandlerAdapter</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;mvcContentNegotiationManager&quot;)</span> ContentNegotiationManager contentNegotiationManager,</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;mvcConversionService&quot;)</span> FormattingConversionService conversionService,</span></span><br><span class="line"><span class="params">            <span class="meta">@Qualifier(&quot;mvcValidator&quot;)</span> Validator validator)</span> &#123;</span><br><span class="line">            <span class="type">RequestMappingHandlerAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="built_in">super</span>.requestMappingHandlerAdapter(contentNegotiationManager,</span><br><span class="line">                                                                                      conversionService, validator);</span><br><span class="line">            adapter.setIgnoreDefaultModelOnRedirect(</span><br><span class="line">                <span class="built_in">this</span>.mvcProperties == <span class="literal">null</span> || <span class="built_in">this</span>.mvcProperties.isIgnoreDefaultModelOnRedirect());</span><br><span class="line">            <span class="keyword">return</span> adapter;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RequestMappingHandlerAdapter部分源码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandlerMethodAdapter</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//后置的属性设置，主要包含初始化argumentResolvers属性</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Do this first, it may add ResponseBody advice beans</span></span><br><span class="line">        initControllerAdviceCache();</span><br><span class="line">        <span class="comment">//初始化argumentResolvers</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers == <span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line">            <span class="built_in">this</span>.argumentResolvers = <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>().addResolvers(resolvers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.initBinderArgumentResolvers == <span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span><br><span class="line">            <span class="built_in">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>().addResolvers(resolvers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line">            <span class="built_in">this</span>.returnValueHandlers = <span class="keyword">new</span> <span class="title class_">HandlerMethodReturnValueHandlerComposite</span>().addHandlers(handlers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>可以知道<code>RequestMappingHandlerAdapter</code>的创建是在项目启动的时候创建了，同样在项目启动的时候，我们的<code>argumentResolverCache</code>就被创建好了。</p>
<p>在执行HTTP请求的时候，invokeHandlerMethod()方法部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                           HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">ServletInvocableHandlerMethod</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">        invocableMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.argumentResolvers);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>每次HTTP请求的时候都会创建一个<code>ServletInvocableHandlerMethod</code>对象，但往<code>ServletInvocableHandlerMethod</code>对象内设置的<code>argumentResolvers</code>是由<code>RequestMappingHandlerAdapter#argumentResolvers</code>属性传进去的，<code>RequestMappingHandlerAdapter</code>是单例的，也即<code>RequestMappingHandlerAdapter#argumentResolvers</code>只有一份，即使每次HTTP请求都创建<code>ServletInvocableHandlerMethod</code>，但每个对象内持有的<code>argumentResolvers</code>都是同一份，再往下追寻：</p>
<p>在<code>ServletInvocableHandlerMethod</code>对象内部执行参数解析操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span><br><span class="line">                                           Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatArgumentError(parameter, <span class="string">&quot;No suitable resolver&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        args[i] = <span class="built_in">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="built_in">this</span>.dataBinderFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>参数解析的时候就会将找到的参数放进<code>argumentResolverCache</code>缓存中，既然所有的<code>ServletInvocableHandlerMethod</code>对象都持有一份<code>argumentResolvers</code>，那自然也持有同一份<code>argumentResolverCache</code>，都是<code>RequestMappingHandlerAdapter</code>里的那一份。因此上一次HTTP请求做的缓存保存，自然可以被下一次HTTP请求使用。</p>
<p>这里也解释了<code>argumentResolverCache</code>是<code>ConcurrentHashMap</code>，而非HashMap，因为请求肯定是并发的，有人往Map里写有人从Map中拿，要保证线程安全。</p>
<p>因此可以得出结论<code>argumentResolverCache</code>是与项目生命周期基本相同的，同一HTTP请求可以被缓存，供以后使用。</p>
<h2 id="5-第三步-执行方法并处理返回"><a href="#5-第三步-执行方法并处理返回" class="headerlink" title="5. 第三步 执行方法并处理返回"></a>5. 第三步 执行方法并处理返回</h2><h3 id="5-1-HandlerMethodReturnValueHandler"><a href="#5-1-HandlerMethodReturnValueHandler" class="headerlink" title="5.1 HandlerMethodReturnValueHandler"></a>5.1 HandlerMethodReturnValueHandler</h3><p>我们上面说了，对于<code>HandlerMethod</code>的返回情况也是多种多样的，比如可以返回视图，可以返回一个对象，对象可以被解析为JSON，还可以被解析为XML返回，可以跳转&#x2F;重定向等等。针对那么多种情况，就需要对返回的结果进行适配处理。</p>
<p>与参数处理器解析器类似，对于返回结果的处理，Spring也抽象为了一个接口叫<code>HandlerMethodReturnValueHandler</code>，翻译为返回值处理器，因此一个<code>HandlerMethodReturnValueHandler</code>的实现类就是一个场景下的返回结果处理。</p>
<p>同样与参数解析器类似，SpringMVC再次采用策略模式，将所有返回值处理器的实现类保存起来，当需要处理返回值的时候就从这些实现类中选择一个来处理返回。</p>
<p><code>RequestMappingHandlerAdapter</code>类中有一个重要的属性<code>returnValueHandlers</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandlerMethodAdapter</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, InitializingBean &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> HandlerMethodReturnValueHandlerComposite returnValueHandlers;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>其中<code>HandlerMethodReturnValueHandlerComposite</code>就是返回值处理器的集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerMethodReturnValueHandlerComposite</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodReturnValueHandler</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>因此<code>RequestMappingHandlerAdapter</code>对象中持有多个<code>HandlerMethodReturnValueHandler</code>实现类，默认情况下<code>RequestMappingHandlerAdapter</code>持有15个返回值处理器（SpringBoot2.7.2版本）</p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208221847838.png"><img src="http://fastly.jsdelivr.net/gh/lowols/Pictures@main/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_Img/1722865555-b36016447dd85ae2537252fedc659fb3.png" alt="image-20220822184726495" title="image-20220822184726495"></a></p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208221847838.png">image-20220822184726495</a></p>
<h3 id="5-2-ServletInvocableHandlerMethod-invokeAndHandle"><a href="#5-2-ServletInvocableHandlerMethod-invokeAndHandle" class="headerlink" title="5.2 ServletInvocableHandlerMethod#invokeAndHandle()"></a>5.2 ServletInvocableHandlerMethod#invokeAndHandle()</h3><p><code>ServletInvocableHandlerMethod</code>类我们之前已经讲过，它就是<code>HandlerMethod</code>的一个包装类，里面装了很多东西，其中上面说的返回值处理器也被装在了里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandlerMethodAdapter</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, InitializingBean &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                               HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将返回值处理器设置进包装类</span></span><br><span class="line">            invocableMethod.setHandlerMethodReturnValueHandlers(<span class="built_in">this</span>.returnValueHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>因此<code>ServletInvocableHandlerMethod</code>在解析完参数并执行完<code>HandlerMethod</code>拿到结果后就开始使用返回值处理器来处理结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                            Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析参数并执行HandlerMethod，得到返回结果</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...一些返回信息的校验</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">        returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">    <span class="comment">//...一些异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>可以看到直接使用<code>returnValueHandlers</code>来处理返回值，因此对返回值的处理就在代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">    returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>我们继续深入。</p>
<h3 id="5-3-HandlerMethodReturnValueHandlerComposite-handleReturnValue"><a href="#5-3-HandlerMethodReturnValueHandlerComposite-handleReturnValue" class="headerlink" title="5.3 HandlerMethodReturnValueHandlerComposite#handleReturnValue()"></a>5.3 HandlerMethodReturnValueHandlerComposite#handleReturnValue()</h3><p>其中<code>HandlerMethodReturnValueHandlerComposite#handleReturnValue()</code>代码也与我们在参数解析器里看到的思路基本相同，从众多返回值处理器实现类中获得能处理的返回值处理器，用这个得到的实现类来处理返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">                              ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//得到返回值处理器</span></span><br><span class="line">    <span class="type">HandlerMethodReturnValueHandler</span> <span class="variable">handler</span> <span class="operator">=</span> selectHandler(returnValue, returnType);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .. 异常处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用得到的返回值处理器处理结果</span></span><br><span class="line">    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>而<code>selectHandler()</code>也很简单，就是遍历挨个问返回值处理器，谁支持处理，谁支持就让谁处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HandlerMethodReturnValueHandler <span class="title function_">selectHandler</span><span class="params">(<span class="meta">@Nullable</span> Object value, MethodParameter returnType)</span> &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">for</span> (HandlerMethodReturnValueHandler handler : <span class="built_in">this</span>.returnValueHandlers) &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">       <span class="comment">//判断是否支持处理</span></span><br><span class="line">      <span class="keyword">if</span> (handler.supportsReturnType(returnType)) &#123;</span><br><span class="line">         <span class="keyword">return</span> handler;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>我们刚才已经看到在SpringBoot2.7.2版本中已经默认带了15个返回值处理器</p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208221847838.png"><img src="http://fastly.jsdelivr.net/gh/lowols/Pictures@main/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_Img/1722865555-b36016447dd85ae2537252fedc659fb3.png" alt="image-20220822184726495" title="image-20220822184726495"></a></p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208221847838.png">image-20220822184726495</a></p>
<p>其中通过类名不难看出，<code>@RequestResponseBodyMethodProcessor</code>是处理返回结果加了<code>@ResponseBody</code>注解的情况（准确来说是<code>HandelrMethod</code>上或者Controller类上加了<code>@ResponseBody</code>注解），<code>ViewNameMethodReturnValueHandler</code>是处理返回结果是视图名的等。</p>
<p><strong>每个返回值处理器都会有一定的应用场景，本文目的是帮助大家快速的掌握SpringMvc执行源码的流程，具体的业务场景不在本文展开，后续会专门出文章，从应用角度讲述这些返回值处理器的源码。</strong></p>
<h3 id="5-4-RequestMappingHandlerAdapter-getModelAndView"><a href="#5-4-RequestMappingHandlerAdapter-getModelAndView" class="headerlink" title="5.4 RequestMappingHandlerAdapter#getModelAndView()"></a>5.4 RequestMappingHandlerAdapter#getModelAndView()</h3><p>执行完获得结果以后，就需要将<code>ModelAndView</code>返回，在上面的源码中我们也看到，<code>HandlerAdapter#handle()</code>的返回是<code>ModelAndView</code>。</p>
<p>返回<code>ModelAndView</code>的源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandlerMethodAdapter</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, InitializingBean &#123;</span><br><span class="line">    <span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                               HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//返回ModelAndView</span></span><br><span class="line">        <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p><code>ModelAndView</code>的获取很简单，就是从mavContainer中得到Model和View信息，返回即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ModelAndView <span class="title function_">getModelAndView</span><span class="params">(ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                                     ModelFactory modelFactory, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...一些更新操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置Model和View</span></span><br><span class="line">    <span class="type">ModelMap</span> <span class="variable">model</span> <span class="operator">=</span> mavContainer.getModel();</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(mavContainer.getViewName(), model, mavContainer.getStatus());</span><br><span class="line">    <span class="comment">//设置View，针对返回不是视图名的情况</span></span><br><span class="line">    <span class="keyword">if</span> (!mavContainer.isViewReference()) &#123;</span><br><span class="line">        mav.setView((View) mavContainer.getView());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//....重定向的特殊处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<h2 id="6-第四步-视图解析"><a href="#6-第四步-视图解析" class="headerlink" title="6. 第四步 视图解析"></a>6. 第四步 视图解析</h2><p>走完了上面那些就到了第四步：视图解析。视图解析不是必须的，只有在需要SpringMVC判断返回结果包含视图的时候才会进行视图解析（也即ModelAndView中的view信息不为空），举个例子：</p>
<p>在配置了</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">view:</span></span><br><span class="line">      <span class="attr">prefix:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">suffix:</span> <span class="string">.html</span></span><br></pre></td></tr></table></figure>

<p>YAML</p>
<p><em>复制</em></p>
<p>Controller层写为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>且静态资源路径下存在hello.html时，我们请求<code>/hello</code>便会返回hello.html页面。</p>
<p>为了最后再加强大家对于SpringMVC执行流程的记忆，我们最后再将<code>DispatcherServlet#doDispatch()</code>四个步骤的重要源码拿过来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//对应步骤1，找到处理方法</span></span><br><span class="line">    mappedHandler = getHandler(processedRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应步骤1，找到处理方法的适配器(适配器我们下面会说，别着急)</span></span><br><span class="line">    <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应步骤2和步骤3，解析参数，执行方法，并处理方法的返回</span></span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应步骤4 视图解析</span></span><br><span class="line">    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>可以看到，第四步的视图解析是<code>processDispatchResult()</code>函数。</p>
<h3 id="6-1-DispatcherServlet-processDispatchResult"><a href="#6-1-DispatcherServlet-processDispatchResult" class="headerlink" title="6.1 DispatcherServlet#processDispatchResult()"></a>6.1 DispatcherServlet#processDispatchResult()</h3><p>其主要源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... 异常校验</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">//解析视图</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//... 一些别的处理，如记录日志和拦截器的triggerAfterCompletion执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>可以看到SpringMVC会先判断ModelAndView不为空且视图信息不为空（较低版本SpringBoot这里是<code>&amp;&amp;mv.view!=null</code>）。</p>
<p>因此视图解析的所有核心源码在<code>render()</code>函数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//...国际化处理</span></span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    <span class="type">String</span> <span class="variable">viewName</span> <span class="operator">=</span> mv.getViewName();</span><br><span class="line">    <span class="keyword">if</span> (viewName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to resolve the view name.</span></span><br><span class="line">        view = resolveViewName(viewName, mv.getModelInternal(), locale, request);</span><br><span class="line">        <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Could not resolve view with name &#x27;&quot;</span> + mv.getViewName() +</span><br><span class="line">                                       <span class="string">&quot;&#x27; in servlet with name &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//... 处理viewName为空的异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mv.getStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置HTTP响应状态码</span></span><br><span class="line">            request.setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, mv.getStatus());</span><br><span class="line">            response.setStatus(mv.getStatus().value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//视图渲染</span></span><br><span class="line">        view.render(mv.getModelInternal(), request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>这里需要讲的一点是<code>View</code>对象，对于视图这一信息，SpringMVC抽象出了一个接口叫<code>View</code>。<code>View</code>接口下的实现类非常多，每个不同的实现类都是一种视图场景。</p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208232230708.png"><img src="http://fastly.jsdelivr.net/gh/lowols/Pictures@main/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_Img/1722865555-8f27e8f1ae25a510187bc8f72b6f07a7.png" alt="image-20220823223018574" title="image-20220823223018574"></a></p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208232230708.png">image-20220823223018574</a></p>
<p>比如处理重定向页面的<code>RedirectView</code>，处理内部视图资源的<code>InternalResourceView</code>。</p>
<p>因此上述<code>render()</code>函数的核心是<strong>先解析视图名得到<code>View</code>对象，再通过<code>View</code>对象做视图渲染</strong>。</p>
<p>我们先看第一个函数，通过视图名得到<code>View</code>对象<code>resolveViewName()</code></p>
<h3 id="6-2-DispatcherServlet-resolveViewName"><a href="#6-2-DispatcherServlet-resolveViewName" class="headerlink" title="6.2 DispatcherServlet#resolveViewName()"></a>6.2 DispatcherServlet#resolveViewName()</h3><h4 id="6-2-1-ViewResolver"><a href="#6-2-1-ViewResolver" class="headerlink" title="6.2.1 ViewResolver"></a>6.2.1 ViewResolver</h4><p>SpringMVC再次借助策略模式，将解析视图名返回View对象这一能力作为策略，策略的接口为<code>ViewResolver</code>。<code>ViewResolver</code>接口下只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ViewResolver</span> &#123;</span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   View <span class="title function_">resolveViewName</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>就是解析视图名称返回<code>View</code>对象。</p>
<p>同样的，大家应该猜到了<code>DispatcherServlet</code>内部持有多个<code>ViewResolver</code>实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">FrameworkServlet</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<h4 id="6-2-2-DispatcherServlet-resolveViewName"><a href="#6-2-2-DispatcherServlet-resolveViewName" class="headerlink" title="6.2.2 DispatcherServlet#resolveViewName()"></a>6.2.2 DispatcherServlet#resolveViewName()</h4><p>有了这些信息后，我们再来看<code>resolveViewName</code>函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> View <span class="title function_">resolveViewName</span><span class="params">(String viewName, <span class="meta">@Nullable</span> Map&lt;String, Object&gt; model,</span></span><br><span class="line"><span class="params">                               Locale locale, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.viewResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewResolver viewResolver : <span class="built_in">this</span>.viewResolvers) &#123;</span><br><span class="line">            <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> viewResolver.resolveViewName(viewName, locale);</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> view;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java</p>
<p><em>复制</em></p>
<p>就是拿到所有的实现类，挨个遍历调用<code>viewResolver.resolveViewName()</code>来解析视图，谁解析出来了(<code>View!=null</code>)就直接返回。</p>
<p>默认情况下<code>DispatcherServlet</code>内部持有4个视图解析器实现类：</p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208232245726.png"><img src="http://fastly.jsdelivr.net/gh/lowols/Pictures@main/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3_Img/1722865555-a2547dc78ce548db9dae2e9e1e7e8087.png" alt="image-20220823224512517" title="image-20220823224512517"></a></p>
<p><a target="_blank" rel="noopener" href="https://coderzoe.oss-cn-beijing.aliyuncs.com/202208232245726.png">image-20220823224512517</a></p>
<p>其实第一个实现类内部持有其他三个实现类，这点我们会以后在具体场景中再讲。</p>
<h3 id="6-3-view-render"><a href="#6-3-view-render" class="headerlink" title="6.3 view.render()"></a>6.3 view.render()</h3><p>视图解析器解析出的View对象后，调用<code>view.render()</code>就可以渲染视图，我们刚才已经看到了<code>View</code>接口下有很多实现类且每个实现类应用场景不同，因此具体的<code>render()</code>我们后续会以具体的场景来分析。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>其实从上到下看过来，发现一切都是一个策略模式（其中还有一个适配器模式），首先根据HTTP请求处理的不同，SpringMVC抽象出了<code>HandlerMapping</code>接口，并且<code>DispatcherServlet</code>对象持有多个<code>HandlerMapping</code>实现类。</p>
<p>一般请求到我们Controller层的由实现类<code>RequestHandlerMapping</code>来处理，SpringMVC会在项目一启动的扫描我们所有Controller下的标了<code>@RequestMapping</code>注解的处理 函数，并将这个处理函数封装成<code>HandlerMethod</code>，使用一个大的集合管理这些<code>HandlerMethod</code>（就是<code>MappingRegistry</code>），因此<code>RequestHandlerMapping</code>会根据请求路径和请求方式从集合中找到合适的<code>HandlerMethod</code>来处理请求。</p>
<p>但是HTTP请求五花八门，我们写的Controller层方法各有不同，为了能比较通用的执行HTTP请求，就需要适配，因此再次借助策略模式，SpringMVC将适配器抽象为接口<code>HandlerAdapter</code>，并且<code>DispatcherServlet</code>对象持有多个<code>HandlerAdapter</code>实现类。</p>
<p>需要适配Controller层方法，也即<code>HandlerMethod</code>的适配器叫做<code>RequestMappingHandlerAdapter</code>，<code>RequestMappingHandlerAdapter</code>作为适配器主要做了两件事：参数解析和返回结果处理。所谓参数解析就是将HTTP请求中的内容解析为我们<code>HandlerMethod</code>上的参数，返回结果处理就是对一些返回的结果做特殊处理并写出到HTTP输出流中，比如将返回的Java对象转为JSON写进输出流。</p>
<p><code>RequestMappingHandlerAdapter</code>的适配工作也依赖于了策略模式，解析参数的时候抽象出一个接口叫<code>HandlerMethodArgumentResolver</code>，同时自己持有多个<code>HandlerMethodArgumentResolver</code>的实现类。<code>RequestMappingHandlerAdapter</code>会遍历我们<code>HandlerMethod</code>上的每一个参数，然后对每个参数都挨个问<code>HandlerMethodArgumentResolver</code>能否解析，如果能解析就解析参数（实际会有个缓存，防止以后再挨个问）。同理返回处理的时候也使用了策略模式，将返回处理抽象为接口<code>HandlerMethodReturnValueHandler</code>，自己持有多个<code>HandlerMethodReturnValueHandler</code>的实现类，在解析完参数并调用<code>MethodHandler</code>执行完处理得到结果后，就开始结果处理，同样挨个调用<code>HandlerMethodReturnValueHandler</code>的实现类，问问它能不能处理，要是能就处理。</p>
<p>在上述这些流程都完成后，最后一步就是视图解析，视图解析一般分为两步，视图名解析和视图渲染。我们一般返回的信息是视图名，SpringMVC将所有视图抽象为接口<code>View</code>，因此就需要根据返回的视图名寻找对应的解析器将视图名解析为<code>View</code>对象，针对这一解析过程，使用策略模式，抽象为接口<code>ViewResolver</code>，<code>DispatcherServlet</code>内持有多个<code>ViewResolver</code>的实现类，也是一样的遍历每个实现类看看能不能解。在得到<code>View</code>对象后，调用<code>View.render()</code>对视图进行渲染，就完成了视图解析。</p>
<p>最后修改：2022 年 09 月 10 日</p>
<p>© 允许规范转载</p>
<p>打赏赞 61</p>
<p>如果觉得我的文章对你有用，请随意赞赏</p>
<h1 id="三-启发"><a href="#三-启发" class="headerlink" title="三 启发"></a>三 启发</h1><p>registry注册与取消handler，使用了读写锁，读多写少场景锁的典型应用</p>
<p>适配器模式，为每个handler提供了适配器</p>
<p>模板方法模式，DispatchServlet与抽象父类应用了模板方法模式</p>
<p>策略模式，handlerMappings<code>和</code>handlerAdapters</p>
<h1 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h1><p>博客参考：</p>
<p>入门：<a target="_blank" rel="noopener" href="https://pdai.tech/md/spring/spring-x-framework-springmvc.html">https://pdai.tech/md/spring/spring-x-framework-springmvc.html</a></p>
<p>原理：<a target="_blank" rel="noopener" href="https://www.coderzoe.com/archives/28/">https://www.coderzoe.com/archives/28/</a></p>
<p>英文博客介绍：<a target="_blank" rel="noopener" href="https://dzone.com/articles/how-spring-mvc-really-works">https://dzone.com/articles/how-spring-mvc-really-works</a></p>
<p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/spring-configure-dispatcher-servlet-in-three-different-ways/">https://www.geeksforgeeks.org/spring-configure-dispatcher-servlet-in-three-different-ways/</a></p>
<p>启动过程： <a target="_blank" rel="noopener" href="https://github.com/wenbin8/doc/blob/master/Spring/05-Spring-MVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">https://github.com/wenbin8/doc/blob/master/Spring/05-Spring-MVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lowols.github.io">Leon Walon</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lowols.github.io/2024/05/15/Java%E7%BC%96%E7%A8%8B/Spring/SrpingMVC/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/">https://lowols.github.io/2024/05/15/Java%E7%BC%96%E7%A8%8B/Spring/SrpingMVC/SrpingMVC%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lowols.github.io" target="_blank">Walon的技术博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringMVC/">SpringMVC</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/15/Java%E7%BC%96%E7%A8%8B/Spring/SrpingMVC/SrpingMVC%E5%AD%A6%E4%B9%A0-%E4%B8%8A-%E5%85%A5%E9%97%A8%E4%B8%8ERESTful/" title="SrpingMVC学习-上-入门与RESTful"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SrpingMVC学习-上-入门与RESTful</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/14/%E5%B7%A5%E5%85%B7/%E6%B5%8B%E8%AF%95markmap/" title="测试markmap"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">测试markmap</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/15/Java%E7%BC%96%E7%A8%8B/Spring/SrpingMVC/SrpingMVC%E5%AD%A6%E4%B9%A0-%E4%B8%8B-SSM%E6%95%B4%E5%90%88%E4%B8%8E%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/" title="SrpingMVC学习-下-SSM整合与常用组件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-15</div><div class="title">SrpingMVC学习-下-SSM整合与常用组件</div></div></a></div><div><a href="/2024/05/15/Java%E7%BC%96%E7%A8%8B/Spring/SrpingMVC/SrpingMVC%E5%AD%A6%E4%B9%A0-%E4%B8%8A-%E5%85%A5%E9%97%A8%E4%B8%8ERESTful/" title="SrpingMVC学习-上-入门与RESTful"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-15</div><div class="title">SrpingMVC学习-上-入门与RESTful</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Leon Walon</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81SpringMVC%E6%A6%82%E8%BF%B0"><span class="toc-text">一、SpringMVC概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-text">1 开发流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Spring-MVC%E4%B8%BB%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">二、Spring-MVC主流程源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC"><span class="toc-text">Spring MVC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%BF%90%E8%A1%8C%E8%B0%83%E7%94%A8%E9%98%B6%E6%AE%B5%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90"><span class="toc-text">二、运行调用阶段源码详细分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94part1-%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-text">SpringMVC处理请求源码分析——part1 整体流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%88%E4%BB%8EDispatcherServlet%E8%AF%B4%E8%B5%B7"><span class="toc-text">1. 先从DispatcherServlet说起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-doDispatch%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">2. doDispatch做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AC%AC%E4%B8%80%E6%AD%A5-%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-text">3. 第一步 找到处理方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%89%BE%E5%88%B0handler"><span class="toc-text">3.1 找到handler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-HandlerMapping"><span class="toc-text">3.1.1 HandlerMapping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-DispatcherServlet-getHandler"><span class="toc-text">3.1.2 DispatcherServlet#getHandler()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-RequestMappingHandlerMapping-getHandler"><span class="toc-text">3.1.3 RequestMappingHandlerMapping#getHandler()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-%E6%80%BB%E7%BB%93"><span class="toc-text">3.1.4 总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5-%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85"><span class="toc-text">3.1.5 一些补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%89%BE%E5%88%B0handlerAdapter"><span class="toc-text">3.2 找到handlerAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-HandlerAdapter"><span class="toc-text">3.2.1 HandlerAdapter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-DispatcherServlet-getHandlerAdapter"><span class="toc-text">3.2.2 DispatcherServlet#getHandlerAdapter()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-RequestMappingHandlerAdapter-support"><span class="toc-text">3.2.3 RequestMappingHandlerAdapter#support()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E6%80%BB%E7%BB%93"><span class="toc-text">3.2.4 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AC%AC%E4%BA%8C%E6%AD%A5-%E8%A7%A3%E6%9E%90%E5%8F%82%E6%95%B0"><span class="toc-text">4. 第二步 解析参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%85%88%E4%BB%8E%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%B4%E8%B5%B7"><span class="toc-text">4.1 先从一个设计模式说起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-text">4.2 参数解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-RequestMappingHandlerAdapter-invokeHandlerMethod"><span class="toc-text">4.2.1 RequestMappingHandlerAdapter#invokeHandlerMethod()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-ServletInvocableHandlerMethod-invokeAndHandle"><span class="toc-text">4.2.2 ServletInvocableHandlerMethod#invokeAndHandle()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-getMethodArgumentValues"><span class="toc-text">4.2.3 getMethodArgumentValues()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-HandlerMethodArgumentResolverComposite-resolveArgument"><span class="toc-text">4.2.4 HandlerMethodArgumentResolverComposite#resolveArgument()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-doInvoke"><span class="toc-text">4.2.5 doInvoke()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-6-%E6%80%BB%E7%BB%93"><span class="toc-text">4.2.6 总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-7-%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85"><span class="toc-text">4.2.7 一些补充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AC%AC%E4%B8%89%E6%AD%A5-%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%E5%B9%B6%E5%A4%84%E7%90%86%E8%BF%94%E5%9B%9E"><span class="toc-text">5. 第三步 执行方法并处理返回</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-HandlerMethodReturnValueHandler"><span class="toc-text">5.1 HandlerMethodReturnValueHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-ServletInvocableHandlerMethod-invokeAndHandle"><span class="toc-text">5.2 ServletInvocableHandlerMethod#invokeAndHandle()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-HandlerMethodReturnValueHandlerComposite-handleReturnValue"><span class="toc-text">5.3 HandlerMethodReturnValueHandlerComposite#handleReturnValue()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-RequestMappingHandlerAdapter-getModelAndView"><span class="toc-text">5.4 RequestMappingHandlerAdapter#getModelAndView()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%AC%AC%E5%9B%9B%E6%AD%A5-%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90"><span class="toc-text">6. 第四步 视图解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-DispatcherServlet-processDispatchResult"><span class="toc-text">6.1 DispatcherServlet#processDispatchResult()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-DispatcherServlet-resolveViewName"><span class="toc-text">6.2 DispatcherServlet#resolveViewName()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-ViewResolver"><span class="toc-text">6.2.1 ViewResolver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-DispatcherServlet-resolveViewName"><span class="toc-text">6.2.2 DispatcherServlet#resolveViewName()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-view-render"><span class="toc-text">6.3 view.render()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-text">7. 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E5%90%AF%E5%8F%91"><span class="toc-text">三 启发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-text">四、参考文章</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/12/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/" title="前端开发核心总结">前端开发核心总结</a><time datetime="2024-10-12T02:06:16.000Z" title="发表于 2024-10-12 10:06:16">2024-10-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/16/Java%E7%BC%96%E7%A8%8B/JavaWeb/JavaWeb_servlet%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%89%8B%E6%92%95MVC%E6%A1%86%E6%9E%B6_04_Filter-Transaction-Listener/" title="JavaWeb_servlet使用与手撕MVC框架_04_Filter-Transaction-Listener">JavaWeb_servlet使用与手撕MVC框架_04_Filter-Transaction-Listener</a><time datetime="2024-06-16T09:49:00.000Z" title="发表于 2024-06-16 17:49:00">2024-06-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/15/Java%E7%BC%96%E7%A8%8B/JavaWeb/JavaWeb_servlet%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%89%8B%E6%92%95MVC%E6%A1%86%E6%9E%B6_03_MVC%E4%B8%8EIOC/" title="JavaWeb_servlet使用与手撕MVC框架_03_MVC与IOC">JavaWeb_servlet使用与手撕MVC框架_03_MVC与IOC</a><time datetime="2024-06-15T09:52:00.000Z" title="发表于 2024-06-15 17:52:00">2024-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/15/Java%E7%BC%96%E7%A8%8B/JavaWeb/JavaWeb_servlet%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%89%8B%E6%92%95MVC%E6%A1%86%E6%9E%B6_02_%E6%89%8B%E6%92%95MVC/" title="JavaWeb_servlet使用与手撕MVC框架_02_手撕MVC">JavaWeb_servlet使用与手撕MVC框架_02_手撕MVC</a><time datetime="2024-06-15T09:51:00.000Z" title="发表于 2024-06-15 17:51:00">2024-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/15/Java%E7%BC%96%E7%A8%8B/JavaWeb/JavaWeb_servlet%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%89%8B%E6%92%95MVC%E6%A1%86%E6%9E%B6_01_tomcat%E4%B8%8Eservlet/" title="JavaWeb_servlet使用与手撕MVC框架_01_tomcat与servlet">JavaWeb_servlet使用与手撕MVC框架_01_tomcat与servlet</a><time datetime="2024-06-15T09:48:00.000Z" title="发表于 2024-06-15 17:48:00">2024-06-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Leon Walon</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js?v=4.13.0"></script></div></div></body></html>