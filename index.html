<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Walon的技术博客 - 欢迎，这里是Walon的博客</title><meta name="author" content="Leon Walon"><meta name="copyright" content="Leon Walon"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="Walon的技术博客">
<meta property="og:url" content="https://lowols.github.io/index.html">
<meta property="og:site_name" content="Walon的技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:author" content="Leon Walon">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lowols.github.io/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Walon的技术博客',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-09-24 22:07:05'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Walon的技术博客"><span class="site-name">Walon的技术博客</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">Walon的技术博客</h1></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/06/16/Java%E7%BC%96%E7%A8%8B/JavaWeb/JavaWeb_servlet%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%89%8B%E6%92%95MVC%E6%A1%86%E6%9E%B6_04_Filter-Transaction-Listener/" title="JavaWeb_servlet使用与手撕MVC框架_04_Filter-Transaction-Listener">JavaWeb_servlet使用与手撕MVC框架_04_Filter-Transaction-Listener</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-06-16T09:49:00.000Z" title="发表于 2024-06-16 17:49:00">2024-06-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">今日内容：    1. 过滤器Filter        2. 事务管理(TransactionManager、ThreadLocal、OpenSessionInViewFilter)        3. 监听器(Listener , ContextLoaderListener)
1 过滤器Filter
Filter也属于Servlet规范
Filter开发步骤：新建类实现Filter接口，然后实现其中的三个方法：init、doFilter、destroy配置Filter，可以用注解@WebFilter，也可以使用xml文件  
Filter在配置时，和servlet一样，也可以配置通配符，例如 @WebFilter(“*.do”)表示拦截所有以.do结尾的请求
过滤器链1）执行的顺序依次是： A B C demo03 C2 B2 A22）如果采取的是注解的方式进行配置，那么过滤器链的拦截顺序是按照全类名的先后顺序排序的3）如果采取的是xml的方式进行配置，那么按照配置的先后顺序进行排序


2 编程式事务管理2.1 事务问题分析
事务默认自动提交，没法保证单个业务操作【包含多个dao ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/06/15/Java%E7%BC%96%E7%A8%8B/JavaWeb/JavaWeb_servlet%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%89%8B%E6%92%95MVC%E6%A1%86%E6%9E%B6_03_MVC%E4%B8%8EIOC/" title="JavaWeb_servlet使用与手撕MVC框架_03_MVC与IOC">JavaWeb_servlet使用与手撕MVC框架_03_MVC与IOC</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-06-15T09:52:00.000Z" title="发表于 2024-06-15 17:52:00">2024-06-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">1 再次学习Servlet的初始化方法1.1 Servlet生命周期：实例化、初始化、服务、销毁1.2 组件配置：ServletConfig生效范围：当前组件可用
1.2.1 使用配置Servlet中的初始化方法有两个：init() , init(config)
其中带参数的方法代码如下：public void init(ServletConfig config) throws ServletException {      this.config &#x3D; config ;      init(); } 另外一个无参的init方法如下： public void init() throws ServletException{ } 如果我们想要在Servlet初始化时做一些准备工作，那么我们可以重写init方法 我们可以通过如下步骤去获取初始化设置的数据

获取config对象：ServletConfig config &#x3D; getServletConfig();
获取初始化参数值： config.getInitParameter(key);

1.2.2 添加配置在web. ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/06/15/Java%E7%BC%96%E7%A8%8B/JavaWeb/JavaWeb_servlet%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%89%8B%E6%92%95MVC%E6%A1%86%E6%9E%B6_02_%E6%89%8B%E6%92%95MVC/" title="JavaWeb_servlet使用与手撕MVC框架_02_手撕MVC">JavaWeb_servlet使用与手撕MVC框架_02_手撕MVC</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-06-15T09:51:00.000Z" title="发表于 2024-06-15 17:51:00">2024-06-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">问题分析servlet规范与我们的业务无关，但现在Request、Response、视图渲染工具类、Redirect等等这些api“打扰”了程序员。
程序员的精力是很宝贵的，我们希望在开发项目时，程序员更专注于业务，而不要看到这些与业务无关的servlet规范api。
我们的目标就是，我们写的代码类就是普通的pojo类。这样的pojo类就是常用Web框架SpringMVC中创建的Controller类。
在使用SpringMVC前，我们在之前的代码基础上，实现一个简易版的SpringMVC框架，加深对框架底层原理和功能的理解。
1 利用switch语句-解决servlet类爆炸问题现在一个方法就定义一个servlet类，类数量过多，不好维护。

我们把Fruit相关的方法都放到一个servlet类中，该类中根据前端传的operate参数，调用对应的方法。

2 引入反射-解决switch判断语句过长问题通过反射来匹配前端operate参数和对应的处理方法
12345678910111213141516171819202122232425262728293031@Override     ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/06/15/Java%E7%BC%96%E7%A8%8B/JavaWeb/JavaWeb_servlet%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%89%8B%E6%92%95MVC%E6%A1%86%E6%9E%B6_01_tomcat%E4%B8%8Eservlet/" title="JavaWeb_servlet使用与手撕MVC框架_01_tomcat与servlet">JavaWeb_servlet使用与手撕MVC框架_01_tomcat与servlet</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-06-15T09:48:00.000Z" title="发表于 2024-06-15 17:48:00">2024-06-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">学习说明你将学到：

如何用tomcat【servlet规范的实现者】搭建一个网站

如何用servlet开发动态资源，并部署到tomcat网站

分析用原生servlet开发的问题

一步步搭建一个MVC框架，屏蔽servlet对业务代码的侵入


1 CS与BS前置知识点：
Java &#x2F; DB &#x2F;JDBCHTML&#x2F;CSS&#x2F;JS
CS:客户端服务器架构模式，比如QQ，游戏LOL优点:充分利用客户端机器的资源，减轻服务器的负荷   (一部分安全要求不高的计算任务存储任务放在客户端执行，不需要把所有的计算和存储都在服务器端执行，从而能够减轻服务器的压力，也能够减轻网络负荷)
缺点:需要安装;升级维护成本较高【以前网速慢，升级打补丁可能需要工程师从上海带着U盘坐飞机到新疆】
BS:浏览器服务器架构模式优点:客户端不需要安装;维护成本较低缺点:所有的计算和存储任务都是放在服务器端的，服务器的负荷较重;在服务端计算完成之后把结果再传输给客户端，因此客户端和服务器端会进行非常频繁的数据通信，从而网络负荷较重
2 Tomcat入门2.1 认识Tomcatse ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/05/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87_02_%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/" title="MySQL高级篇_02_索引及调优篇">MySQL高级篇_02_索引及调优篇</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-30T06:19:00.000Z" title="发表于 2024-05-30 14:19:00">2024-05-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="content">MySQL高级篇_02_索引及调优篇第06章_索引的数据结构1. 为什么使用索引全表扫描与磁盘IO索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。

Col 2 没有索引，我们查找 Col 2 &#x3D; 89 这条记录，就要逐行去查找、去比较。如果表很大的话，有上千万条数据，数据分布在硬盘不同的位置上面，摆臂需要前后摆动查询数据，读就意味着要做很多很多次硬盘I/0才能找到。最耗时间就是磁盘I&#x2F;O（涉及到磁盘的旋转时间（速度较快），磁头的寻道时间(速度慢、费时)）
索引的原理假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示

对字段 Col 2 添加了索引，就相当于在硬盘上为 Col 2 维护了一个索引的数据结构，即这个 二叉搜索树。二叉搜索树的每个结点存储的是 (K, V) 结构，key 是 Co ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/05/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87_01_%E6%9E%B6%E6%9E%84%E7%AF%87/" title="MySQL高级篇_01_架构篇">MySQL高级篇_01_架构篇</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-30T05:19:00.000Z" title="发表于 2024-05-30 13:19:00">2024-05-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="content">第04章_逻辑架构1. 逻辑架构剖析1.1 服务器处理客户端请求首先MySQL是典型的C&#x2F;S架构，即Clinet/Server 架构，服务端程序使用的mysqld。
不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果是：客户端进程向服务器进程发送一段文本（SQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。
那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为 例展示：

下面具体展开如下：

1.2 ConnectorsConnectors, 指的是不同语言中与SQL的交互。MySQL首先是一个网络程序，在TCP之上定义了自己的应用层协议。所以要使用MySQL，我们可以编写代码，跟MySQL Server 建立TCP连接，之后按照其定义好的协议进行交互。或者比较方便的方法是调用SDK，比如Native C API、JDBC、PHP等各语言的MySQL Connecotr,或者通过ODBC。但通过SDK来访问MySQL，本质上还是在TCP连接上通过MySQL协议跟MySQL进行交互
接下来的MySQL Se ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/05/29/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98_06_%E5%8E%9F%E7%90%86%E7%AF%87/" title="Redis入门到实战_06_原理篇">Redis入门到实战_06_原理篇</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-29T09:50:00.000Z" title="发表于 2024-05-29 17:50:00">2024-05-29</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="content">Redis原理篇1、原理篇-Redis数据结构数据结构和数据类型是两个概念。
数据类型可以看作是Redis暴露给客户端的，用户可见的的API。  
数据结构是Redis服务端底层组织存储数据的真正方式。
我们常见的Redis数据类型有String，List，Set，ZSet等，然而对于每一种数据类型，Redis服务端底层对应着多种数据结构。Redis综合节省空间，处理性能等方面的考虑，根据当前数据的特点【规模，元素大小等】，Redis会灵活的使用不同的数据结构来存储数据。
1.1 Redis数据结构-动态字符串我们都知道Redis中保存的Key是字符串，value往往是字符串或者字符串的集合。可见字符串是Redis中最常用的一种数据结构。
不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：

获取字符串长度的需要通过运算【最后结束字符是\0，需要运算，通过数组长度-1】
非二进制安全 【最后结束字符是\0，如果字符串需要保存\0，会有数据安全问题】
不可修改 【字面量在常量池中，不支持修改和扩容】

Redis构建了一种新的字符串结构，称为简单动态字符串（Sim ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/05/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98_05_%E9%AB%98%E7%BA%A7%E7%AF%87-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="Redis入门到实战_05_高级篇-最佳实践">Redis入门到实战_05_高级篇-最佳实践</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-28T09:49:00.000Z" title="发表于 2024-05-28 17:49:00">2024-05-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="content">Redis高级篇之最佳实践今日内容


Redis键值设计
批处理优化
服务端优化
集群最佳实践


1、Redis键值设计1.1、优雅的key结构Redis的Key虽然可以自定义，但最好遵循下面的几个最佳实践约定：

遵循基本格式：[业务名称]:[数据名]:[id]
长度不超过44字节
不包含特殊字符

例如：我们的登录业务，保存用户信息，其key可以设计成如下格式：

这样设计的好处：

可读性强
避免key冲突
方便管理
更节省内存： key是string类型，底层编码包含int、embstr和raw三种。embstr在小于44字节使用，采用连续内存空间，内存占用更小。当字节数大于44字节时，会转为raw模式存储，在raw模式下，内存空间不是连续的，而是采用一个指针指向了另外一段内存空间，在这段空间里存储SDS内容，这样空间不连续，访问的时候性能也就会收到影响，还有可能产生内存碎片


1.2、拒绝BigKeyBigKey通常以Key的大小和Key中成员的数量来综合判定，例如：

Key本身的数据量过大：一个String类型的Key，它的值为5 MB
Key中的成员数过多：一个Z ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/05/28/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98_04_%E9%AB%98%E7%BA%A7%E7%AF%87-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/" title="Redis入门到实战_04_高级篇-多级缓存">Redis入门到实战_04_高级篇-多级缓存</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-28T09:48:00.000Z" title="发表于 2024-05-28 17:48:00">2024-05-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="content">多级缓存亿级流量的缓存方案。淘宝，京东等网站一天可能面临亿级流量的冲击。传统的缓存方案不满足需要，这时候就需要多级缓存。
1.什么是多级缓存传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图：

存在下面的问题：
•我们知道Tomcat的并发能力不如redis，请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈。
•Redis缓存失效时，会对数据库产生冲击
多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：

浏览器访问静态资源时，优先读取浏览器本地缓存
访问非静态资源（ajax查询数据）时，访问服务端
请求到达Nginx后，优先读取Nginx本地缓存
如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）
如果Redis查询未命中，则查询Tomcat
请求进入Tomcat后，优先查询JVM进程缓存
如果JVM进程缓存未命中，则查询数据库


在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/05/26/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98_03_%E9%AB%98%E7%BA%A7%E7%AF%87-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" title="Redis入门到实战_03_高级篇-分布式缓存">Redis入门到实战_03_高级篇-分布式缓存</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-26T09:48:00.000Z" title="发表于 2024-05-26 17:48:00">2024-05-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="content">分布式缓存– 基于Redis集群解决单机Redis存在的问题
单机的Redis存在四大问题：

0.学习目标1.Redis持久化Redis有两种持久化方案：

RDB持久化
AOF持久化

1.1.RDB持久化RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。
1.1.1.执行时机RDB持久化在四种情况下会执行：

执行save命令
执行bgsave命令
Redis停机时
触发RDB条件时

1）save命令
执行下面的命令，可以立即执行一次RDB：

save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。
2）bgsave命令
下面的命令可以异步执行RDB：

这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。
3）停机时
Redis停机时会执行一次save命令，实现RDB持久化。
4）触发RDB ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/#content-inner">5</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Leon Walon</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/16/Java%E7%BC%96%E7%A8%8B/JavaWeb/JavaWeb_servlet%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%89%8B%E6%92%95MVC%E6%A1%86%E6%9E%B6_04_Filter-Transaction-Listener/" title="JavaWeb_servlet使用与手撕MVC框架_04_Filter-Transaction-Listener">JavaWeb_servlet使用与手撕MVC框架_04_Filter-Transaction-Listener</a><time datetime="2024-06-16T09:49:00.000Z" title="发表于 2024-06-16 17:49:00">2024-06-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/15/Java%E7%BC%96%E7%A8%8B/JavaWeb/JavaWeb_servlet%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%89%8B%E6%92%95MVC%E6%A1%86%E6%9E%B6_03_MVC%E4%B8%8EIOC/" title="JavaWeb_servlet使用与手撕MVC框架_03_MVC与IOC">JavaWeb_servlet使用与手撕MVC框架_03_MVC与IOC</a><time datetime="2024-06-15T09:52:00.000Z" title="发表于 2024-06-15 17:52:00">2024-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/15/Java%E7%BC%96%E7%A8%8B/JavaWeb/JavaWeb_servlet%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%89%8B%E6%92%95MVC%E6%A1%86%E6%9E%B6_02_%E6%89%8B%E6%92%95MVC/" title="JavaWeb_servlet使用与手撕MVC框架_02_手撕MVC">JavaWeb_servlet使用与手撕MVC框架_02_手撕MVC</a><time datetime="2024-06-15T09:51:00.000Z" title="发表于 2024-06-15 17:51:00">2024-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/15/Java%E7%BC%96%E7%A8%8B/JavaWeb/JavaWeb_servlet%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%89%8B%E6%92%95MVC%E6%A1%86%E6%9E%B6_01_tomcat%E4%B8%8Eservlet/" title="JavaWeb_servlet使用与手撕MVC框架_01_tomcat与servlet">JavaWeb_servlet使用与手撕MVC框架_01_tomcat与servlet</a><time datetime="2024-06-15T09:48:00.000Z" title="发表于 2024-06-15 17:48:00">2024-06-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/MySQL%E9%AB%98%E7%BA%A7%E7%AF%87_02_%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87/" title="MySQL高级篇_02_索引及调优篇">MySQL高级篇_02_索引及调优篇</a><time datetime="2024-05-30T06:19:00.000Z" title="发表于 2024-05-30 14:19:00">2024-05-30</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java/"><span class="card-category-list-name">Java</span><span class="card-category-list-count">21</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="card-category-list-name">前端</span><span class="card-category-list-count">1</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/CSS/"><span class="card-category-list-name">CSS</span><span class="card-category-list-count">1</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/"><span class="card-category-list-name">后端</span><span class="card-category-list-count">16</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="card-category-list-name">数据库</span><span class="card-category-list-count">7</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%95%B0%E5%AD%A6/"><span class="card-category-list-name">数学</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E6%8A%80%E8%83%BD/"><span class="card-category-list-name">生活技能</span><span class="card-category-list-count">1</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E6%8A%80%E8%83%BD/%E5%81%9A%E9%A5%AD/"><span class="card-category-list-name">做饭</span><span class="card-category-list-count">1</span></a></li></ul></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/Spring/" style="font-size: 1.26em; color: #999fa8">Spring</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.34em; color: #99a3b0">数据库</a> <a href="/tags/Mybatis/" style="font-size: 1.1em; color: #999">Mybatis</a> <a href="/tags/MySQL/" style="font-size: 1.18em; color: #999ca1">MySQL</a> <a href="/tags/HTML5/" style="font-size: 1.1em; color: #999">HTML5</a> <a href="/tags/%E5%81%9A%E9%A5%AD/" style="font-size: 1.1em; color: #999">做饭</a> <a href="/tags/%E6%96%87%E6%A1%A3%E7%BC%96%E8%BE%91/" style="font-size: 1.18em; color: #999ca1">文档编辑</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 1.18em; color: #999ca1">消息队列</a> <a href="/tags/Redis/" style="font-size: 1.42em; color: #99a6b7">Redis</a> <a href="/tags/%E5%AE%B9%E5%99%A8/" style="font-size: 1.1em; color: #999">容器</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.1em; color: #999">数学</a> <a href="/tags/JDBC/" style="font-size: 1.1em; color: #999">JDBC</a> <a href="/tags/ES/" style="font-size: 1.18em; color: #999ca1">ES</a> <a href="/tags/Java/" style="font-size: 1.26em; color: #999fa8">Java</a> <a href="/tags/SpringMVC/" style="font-size: 1.26em; color: #999fa8">SpringMVC</a> <a href="/tags/Web/" style="font-size: 1.1em; color: #999">Web</a> <a href="/tags/JavaWeb/" style="font-size: 1.5em; color: #99a9bf">JavaWeb</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 1.34em; color: #99a3b0">微服务</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><span class="card-archive-list-count">4</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><span class="card-archive-list-count">38</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><span class="card-archive-list-count">4</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">46</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-09-24T14:07:04.978Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Leon Walon</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>